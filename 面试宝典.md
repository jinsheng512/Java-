[腾讯](https://www.nowcoder.com/jump/super-jump/word?word=腾讯)特别喜欢操作系统和网络，字节和虾皮喜欢[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，[网易](https://www.nowcoder.com/jump/super-jump/word?word=网易)喜欢问框架



#### 1. 计算机系统

https://blog.csdn.net/FlyingFish868/article/details/118666884

##### 1.1  lvs四层转发和nginx七层转发的区别？

https://www.cnblogs.com/guixia621/p/6426765.html

##### 1.2 进程间的通信方式有哪些

```
管道（匿名和非匿名）
信号量
socker
消息队列
共享内存
```

##### 1.3 负载均衡算法

```
1、轮询法

　　将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

2、随机法

     通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，

其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。

3、源地址哈希法

     源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。

4、加权轮询法

　　不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

5、加权随机法

     与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。

6、最小连接数法

     最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前

积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。


```

##### 1.4 虚拟内存，虚拟地址

https://blog.csdn.net/qq_34116958/article/details/108399579

```

```



##### 1.5 进程和线程的区别

```
进程（process）：
一个程序在一个数据集上的一次运行过程。
系统资源分配的单位。
一个程序在不同数据集合上运行或一个程序在同样数据集上的多次运行都是不同的进程。
进程是独立的，有自己的内存空间和上下文环境，无法获取其他进程的存储空间。
同一进程的两段代码不能同时执行，除非引入线程。

线程（thread）：
进程的一个实体，是被系统独立调度和执行的基本单位，CPU调度的基本单位。
同一进程的线程可以共享同一内存空间。
线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。
线程占用的资源少于进程占用的资源。

线程是进程的一部分，一个线程只能有一个进程，一个进程可以有多个线程


进程是系统资源分配的最小单位，拥有自己的存储空间和上下文
线程是CPU调度的基本单位，多个线程共享内存空间
线程是进程的一部分，一个进程可以有多个线程

```

##### 1.6 零拷贝

##### 1.7 **happens-before规则**

https://www.cnblogs.com/tiancai/p/9636199.html

https://zhuanlan.zhihu.com/p/126275344

```
指前一个操作的执行结果必须对后一个操作可见，如果不满足这个要求那就不允许这两个操作进行重排序

happens-before规则

1、程序顺序规则：单个线程中的每个操作，happens-before于改线程中的任意后续操作。

2、监视器锁规则：对一个锁的解锁unlock操作，一定是happens-before于对这个锁的加锁lock操作。

3、volatile变量规则：对一个volatile修饰的变量的写操作，happens-before于任意后续对这个volatile变量的度操作。

4、传递性：如果a happens-before b，且b happens-before c，那么a happens-before c。

5、start()规则：如果线程a执行操作ThreadB.start(),那么a线程的ThreadB.start()操作happens-before于线程B中的任意操作。

6、join()规则：如果线程a执行操作ThreadB.join()并成功返回，那么线B中任意操作

happens-before于线程a从ThreadB.join()操作成功返回。
```

1.8

1.9

1.10

1.11

1.12

1.13

1.14

1.15

1.16

1.17

1.18



#### 2. 计算机网络

##### 2.1  七层协议合四层协议

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQUkM2ib9WWjiabWHbbF0B7Sq5B0RAMJwaTicopuxPlRia1x3uTEbBYD1SD4nLQM14EOibHJQV6pTjZUqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQUkM2ib9WWjiabWHbbF0B7SqiaAu3Unibiao8IWH1xIowmLQkSZmPjl3lXMznXicZmz98bbvZQFwnjpicDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
osi七层模型可以说是面试必考基础了
从上到下分别是：

应用层：文件传输，常用协议HTTP，snmp,FTP ,

表示层：数据格式化，代码转换，数据加密，

会话层：建立，解除会话

传输层：提供端对端的接口，tcp,udp

网络层：为数据包选择路由，IP，icmp

数据链路层：传输有地址的帧

物理层：二进制的数据形式在物理媒体上传输数据
```



###### 常见面试题

##### 2.2**三次握手**的过程

![图片](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD58Npf1AOxttKsHPFl4aOQ54Znzk6P3mic47cYsh2RLgQMibV4I8iaKbZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### 2.3**为什么要三次握手**

```

1. 保证双方发送接收功能都正常
2. 握手的重点就是同步初始序列号
```

##### 2.4 **SYN 超时了怎么处理？**

```
也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？
超时重传

在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。
```

##### 2.5 **SYN Flood 攻击**

```
你看到没 SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server 发 SYN 但就是不回 server。

解决方案：

1. tcp_syncookies

2. 或者调整 tcp_synack_retries 减少重试的次数，设置 tcp_max_syn_backlog 增加 SYN 队列数，设置 tcp_abort_on_overflow SYN 队列满了直接拒绝连接。
```

##### 2.6 **四次挥手**的过程

![图片](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDfa4qx2k7PGicQrGqVPIbqNbIxmbzEicT8F1mtgFbGfmxjGWlricibfgy1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



##### 2.7 **为什么要四次握手**

```
主动关闭方的状态是 FIN_WAIT_1 到 FIN_WAIT_2 然后再到 TIME_WAIT，而被动关闭方是 CLOSE_WAIT 到 LAST_ACK。

确保双方都关闭了，四次挥手是因为 TCP 是全双工协议，因此双方都得说拜拜。

那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？

```

##### 2.8 **为什么要有TimeWait**

```
1. 服务器没有接收到 ack，可以重传fin

2. 为了保证最后一个ACK正常的丢失，因为不确认对方是否收到，需要等1个MSL，至于另一个MSL，能找到比较信服的解释就是被动关闭的一方在收到ACK的那一刻之前重发了FIN，为了保证这个FIN正常丢失，需要再等1个MSL
```

##### 2.9 **TCP 和 UDP区别**

```
1. 可靠和不可靠
2. 传播速度

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
```

##### 2.10 **TCP参数**

```
tcp_syncookies ， SYN Flood 攻击

tcp_syn_retries, 第一次握手

tcp_synack_retries， 第二次握手

tcp_tw_reuse ， 重用链接
```



##### 2.11 **TCP 是如何保证可靠性的**

https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgTfasBzdn2sIB39aFcqL22zhAa7v9d9vR1oZF4mibLUKouDEfKjYoZww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
1. 确认序列号
2. 校验和
3. 重传机制：

   快速重传
   超时重传

4. 拥塞控制：

   慢启动
   拥塞避免
   拥塞发生
   快速恢复
   

5. 流量控制：

   滑动窗口
   
   
6. 三次握手和四次挥手
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgDicBugvroe9EtiaFU38hk4JuVfDciauVPfecBNp8TPI1zkoqbibePA4dlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgR3w50EdpWF95ZM6QPpELCF3P1niazia8nBrSQUvX7e7F7LXMiaXR3iayUA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### 2.12 **TCP超时重传机制是为了解决什么问题？**

```
前面我们提到 TCP 要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。

TCP 的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要 5 那说明前面四个包你都收到了，就是这么回事儿。

不过这里要注意，SeqNum 和 ACK 都是以字节数为单位的，也就是说假设你收到了1、2、4 但是 3 没有收到你不能 ACK 5，如果你回了 5 那么发送方就以为你5之前的都收到了。

所以只能回复确认最大连续收到包，也就是 3。

而发送方不清楚 3、4 这两个包到底是还没到呢还是已经丢了，于是发送方需要等待，这等待的时间就比较讲究了。

如果太心急可能 ACK 已经在路上了，你这重传就是浪费资源了，如果太散漫，那么接收方急死了，这死鬼怎么还不发包来，我等的花儿都谢了。

所以这个等待超时重传的时间很关键，怎么搞？聪明的小伙伴可能一下就想到了，你估摸着正常来回一趟时间是多少不就好了，我就等这么长。

这就来回一趟的时间就叫 RTT，即 Round Trip Time，然后根据这个时间制定超时重传的时间 RTO，即 Retransmission Timeout。

不过这里大概只好了 RTO 要参考下 RTT ，但是具体要怎么算？首先肯定是采样，然后一波加权平均得到 RTO。
```



##### 2.13 **TimeWait 过多解决办法**

```
如果服务器出了异常，百分之八九十都是下面两种情况：

1.服务器保持了大量TIME_WAIT状态

2.服务器保持了大量CLOSE_WAIT状态

因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着应用程序可能返回大量Too Many Open Files异常。

先来说一说长连接和短连接，在HTTP1.1协议中，有个 Connection 头，Connection有两个值，close和keep-alive，这个头就相当于客户端告诉服务端，服务端你执行完成请求之后，是关闭连接还是保持连接。如果服务器使用的短连接，那么每次客户端请求后，服务器都会主动发送FIN关闭连接。最后进入time_wait状态。可想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态。让服务器能够快速回收和重用那些TIME_WAIT的资源，可以修改内核参数。

修改/etc/sysctl.conf如下：

#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间

net.ipv4.tcp_syn_retries=2

#net.ipv4.tcp_synack_retries=2

#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒

net.ipv4.tcp_keepalive_time=1200

net.ipv4.tcp_orphan_retries=3

#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间

net.ipv4.tcp_fin_timeout=30

#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_syn_backlog = 4096

#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭

net.ipv4.tcp_syncookies = 1

#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭

net.ipv4.tcp_tw_reuse = 1

#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭

net.ipv4.tcp_tw_recycle = 1

##减少超时前的探测次数

net.ipv4.tcp_keepalive_probes=5

##优化网络设备接收队列

net.core.netdev_max_backlog=3000

修改完之后执行/sbin/sysctl -p让参数生效。


```

##### 2.14 **closeWait过多解决办法**



```
如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出FIN信号，一般原因都是TCP连接没有调用关闭方法。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行，一定程度上，可以使用TCP的KeepAlive功能，让操作系统替我们自动清理掉CLOSE_WAIT连接。

但是实际上，还是主要是因为我们的程序代码有问题

```



##### 2.15 **TCP保活机制**

```
定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个「探测报文」，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制

tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；

tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。
```



##### 2.16 **TCP和IP报文是否会分片，分别在什么情况下会分片，TCP分包之后是否还会进行ip分片**

```

```

##### 2.17 什么是僵尸进程和孤儿进程

https://www.cnblogs.com/wqbin/p/14306797.html

###### 僵尸进程

```
在UNIX 系统中，一个进程结束了，但是他的父进程没有等待（调用wait / waitpid）他，那么他将变成一个僵尸进程。通过ps命令查看其带有defunct的标志。僵尸进程是一个早已死亡的进程，但在进程表 （processs table）中仍占了一个位置（slot）。
但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个 进程是刚刚结束的这个进程的子进程，如果是的话，就由Init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而Init进程会自动 wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。

当你运行一个程序时，它会产生一个父进程以及很多子进程。 所有这些子进程都会消耗内核分配给它们的内存和 CPU 资源。
这些子进程完成执行后会发送一个 Exit 信号然后死掉。这个 Exit 信号需要被父进程所读取。父进程需要随后调用 wait 命令来读取子进程的退出状态，并将子进程从进程表中移除。
若父进程正确第读取了子进程的 Exit 信号，则子进程会从进程表中删掉。
但若父进程未能读取到子进程的 Exit 信号，则这个子进程虽然完成执行处于死亡的状态，但也不会从进程表中删掉。
```

###### 孤儿进程

```
1、孤儿进程的产生

       一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程收养，并由init进程对它们进行状态收集工作。

2、孤儿进程的处理

      由于孤儿进程已被init进程收养，那就相当于其有了一个父进程，因此并不需要做特殊处理。


```



##### 2.18 僵尸进程怎么解决

https://blog.csdn.net/qq_20218109/article/details/52078076?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link

```
一、让僵尸进程的父进程来回收，父进程每隔一段时间来查询子进程是否结束并回收，调用wait()或者waitpid(),通知内核释放僵尸进程

二、采用信号SIGCHLD通知处理，并在信号处理程序中调用wait函数

三、让僵尸进程变成孤儿进程，由init回收，就是让父亲先死


```

##### 2.19**网络诊断工具**

tcpdump

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZctmf3ObkESj41ayTbgy9q4QJeG04D7HqJAtc1eXjZ6aA6iabfibibezjAV15yyf9jPcJLSM9JLQgwzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
命令行：

tcpdump -i eth icmp and host 192.168.66.44 -nn
```



#### 2.20 http**发展史**

```
1.0 ， 短连接
1.1 ， 长连接，摘要算法加密，(MD5，sha1),管道技术，并行
2.0 ， 头部压缩，IO多路复用epoll
```

##### 2.21 https **工作原理**

```
是基于http上添加的一个安全传输层
1，客户端https发起请求,服务端返回证书和秘钥
2，客户端验证证书是否正确，不正确就提示
3，客户端生产对称性加密密码，并用服务端的秘钥加密
4，服务端拿到客户端传过来的数据，并用其私钥进行解密，便可进行通信


证书预置和申请
1：客户端浏览器会预置根证书， 里面包含CA公钥
2：服务器去CA申请一个证书
3： CA用自己的签名去签一个证书，指纹信息保存在证书的数字摘要里面， 然后发送给服务器

一次访问流程（简化）
1： 客户端 sayHello
2： 服务器返回证书
3-1： 客户端验证证书内容有效性（过期时间， 域名是否相同等）
3-2： 验证证书的有效性 （是否被串改）， 通过本地根证书的CA公钥解密数字摘要，看是否匹配。
3-3：如果数字签名验证通过， 就可以使用服务器证书里面提供的公钥进行下一步通信。
```

##### 2.22 https**客户端是如何验证证书**

```
客户端会向CA确认证书的有效性。 浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：

验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证； 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；

判断证书是否被篡改。需要与 CA 服务器进行校验；

判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率 

以上任意一步都满足的情况下浏览器才认为证书是合法的。
```

##### 2.23 http**常见请求头和响应头**

```
一、常用的http请求头

1.Accept

Accept: text/html  浏览器可以接受服务器回发的类型为 text/html。

Accept: */*   代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。

2.Accept-Encoding

Accept-Encoding: gzip, deflate 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。

3.Accept-Language

Accept-Language:zh-CN,zh;q=0.9  浏览器申明自己接收的语言。

4.Connection

Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

 Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

5.Host（发送请求时，该报头域是必需的）

Host:www.baidu.com 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。

6.Referer

Referer:https://www.baidu.com/?start=1当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

7.User-Agent

User-Agent:Mozilla/...，告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

8.Cache-Control

Cache-Control:private 默认为private  响应只能够作为私有的缓存，不能再用户间共享

Cache-Control:public 响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.

Cache-Control:must-revalidate  响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。

Cache-Control:no-cache  响应不会被缓存,而是实时向服务器端请求资源。

Cache-Control:max-age=10 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。

Cache-Control:no-store 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

9.Cookie

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

10.Range（用于断点续传）

Range:bytes=0-5 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

二、常用的http响应头

1.Cache-Control（对应请求中的Cache-Control）

Cache-Control:private 默认为private 响应只能够作为私有的缓存，不能再用户间共享

Cache-Control:public 浏览器和缓存服务器都可以缓存页面信息。

Cache-Control:must-revalidate 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。

Cache-Control:no-cache 浏览器和缓存服务器都不应该缓存页面信息。

Cache-Control:max-age=10  是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。

Cache-Control:no-store 请求和响应的信息都不应该被存储在对方的磁盘系统中。

2.Content-Type

Content-Type：text/html;charset=UTF-8 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

3.Content-Encoding

Content-Encoding:gzip 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

4.Date

Date: Tue, 03 Apr 2020 03:52:28 GMT 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

5.Server

Server：Tengine/1.4.6  这个是服务器和相对应的版本，只是告诉客户端服务器信息。

6.Transfer-Encoding

Transfer-Encoding：chunked 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

7.Expires

Expires:Sun, 1 Jan 1994 01:00:00 GMT 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

8.Last-Modified

Last-Modified: Dec, 26 Dec 2019 17:30:00 GMT 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

9.Connection

Connection：keep-alive 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

10.Etag

ETag: "637060cd8c284d8af7ad3082f209582d" 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

11.Refresh

Refresh: 5; url=http://baidu.com  用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。

12.Access-Control-Allow-Origin 

Access-Control-Allow-Origin: *   *号代表所有网站可以跨域资源共享，如果当前字段为*那么Access-Control-Allow-Credentials就不能为true

Access-Control-Allow-Origin: www.baidu.com 指定哪些网站可以跨域资源共享

13.Access-Control-Allow-Methods

Access-Control-Allow-Methods：GET,POST,PUT,DELETE  允许哪些方法来访问

14.Access-Control-Allow-Credentials

Access-Control-Allow-Credentials: true  是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true

15.Content-Range

Content-Range: bytes 0-5/7877 指定整个实体中的一部分的插入位置，它也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。 作者：SKYLINE公寓11 https://www.bilibili.com/read/cv6259072/ 出处：bilibili
```

##### 2.24**常见的状态码**

https://www.jianshu.com/p/369db1ba04ea

```
2**开头 （请求成功）表示成功处理了请求的状态代码。

200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201 （已创建） 请求成功并且服务器创建了新的资源。
202 （已接受） 服务器已接受请求，但尚未处理。
203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206 （部分内容） 服务器成功处理了部分 GET 请求。

3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
400 （错误请求） 服务器不理解请求的语法。
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403 （禁止） 服务器拒绝请求。
404 （未找到） 服务器找不到请求的网页。
405 （方法禁用） 禁用请求中指定的方法。
406 （不接受） 无法使用请求的内容特性响应请求的网页。
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408 （请求超时） 服务器等候请求时发生超时。
409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

500 （服务器内部错误） 服务器遇到错误，无法完成请求。
501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。


```



##### 2.25**常见加密算法**

```
对称加密： DES,AES
非对称加密： RSA,ECC
摘要算法： MD5，SHA
```



##### 2.26 DNS

###### DNS劫持是什么，怎么解决

```
DNS劫持是黑客入侵网站的常见手段。这种攻击会返回虚假信息，甚至无法访问网站。DNS劫持是比如你进入360的网站，但它是从百度的页面出来的。这意味着你的DNS被劫持了。

专业的DNS劫持，称为域名系统，是指在被劫持的网络范围内拦截域名解析请求，分析请求的域名，发布超出审查范围的请求，否则返回虚假IP地址或不做任何事情都会使请求失去响应，其效果是特定网络无法响应或返回假地址。 

DNS解析原则以下示例，正常情况下：用户在浏览器中输入帝恩思的域名，然后计算机向DNS服务器发送请求，询问帝恩思该域名的IP地址是什么？查询完成后，服务器返回帝恩思域名对应的IP地址：1.1.1.1，计算机访问该IP地址 作者：haizi0012 https://www.bilibili.com/read/cv8896654/ 出处：bilibili
```

###### DNS**的结构**

- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdCwxNydn5YuT0s7aLuqWCvN6F6eZ2vAU04o8gh1mJ6l7ovc7wsCvTVMvCFHyHqfsRUKtWYnblsCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



###### 工作原理

```
客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。

本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。

根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”

本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com  的 IP 地址吗？”

顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。

本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。

权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。

本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。
```



##### 2..27 CDN

**工具varnish**

https://blog.csdn.net/xiangzhihong8/article/details/83147542

![在这里插入图片描述](https://img-blog.csdn.net/20181018152139324)

##### 2.28 Socket通信

https://www.jianshu.com/p/dd01db305548

##### 2.29 HTTP协议的缓存策略有哪些？ 



##### 2.30 TCP/IP元祖

```
四元组是：

　　源IP地址、目的IP地址、源端口、目的端口

五元组是：

　　源IP地址、目的IP地址、协议号、源端口、目的端口

七元组是：

　　源IP地址、目的IP地址、协议号、源端口、目的端口、服务类型、接口索引
```

##### 2.31 套接字(Sockets)

```
代码详解
服务端实现上述效果流程：

创建套接字，即实例化。server = socket.socket()
绑定地址，且地址是一个元组，里面包括ip和端口，为自己创建了一个地址，用于客户端的连接。server.bind(('127.0.0.5',8520))
开始监听，此时的套接字server才被真正叫做监听套接字，自此之前，客户端是无法连接过来的。代码中的5表示最大能同时连接到客户端的数量。server.listen(5)
收到连接请求就建立与客户端连接，返回结果由两个变量接收，第一个变量是对等连接套接字，第二个是客户端的地址（ip和端口）a,b = server.accept()，这里要特别注意是会有阻塞现象，阻塞在下面介绍。
利用对等连接套接字开启接收信息状态。若接到空值，表示客户端已主动断开连接。这里也会产生一次阻塞，客户端是无法发送空值的。代码的1024表示可以接收的最大字节数。a.recv(1024)
信息传递讲究一收一发，一发一收。若收到信息，应给客户端一个回复。这里要注意的是信息的传递是以字节的形式。a.send(date)
若收到空值，最后一步是断开连接。a.close()
客户端实现上述效果流程：

创建套接字，即实例化生成客户端套接字。client = socket.socket()
向服务端发送连接请求，连接成功后，原本的客户端套接字实际上就变成了对等连接套接字。代码中的ip和端口是服务端的ip和端口。client.connect(('127.0.0.5',8520))
向服务端发送信息。client.send(mess)
向服务端接收信息，这里会发生一次阻塞。client.recv(1024)
主动断开与服务端的连接，这时客户端会自动向服务端发送一个空值。client.close()
什么是阻塞？

最早我们见过的阻塞应该是input，但那时我们应该还没有这方面的认识，阻塞是指当代码运行的这里时，需要触发到某个条件，代码才能继续运行下去，否则会一直堵在这。而最早见的input，我们只要输入字符再按enter就可以继续运行了。在套接字中我们碰到两个阻塞，一个是accept，它的疏通条件是客户端发送连接请求，还有一个是recv，它的疏通条件是接收的对方发来的信息。
```



2.32

2.33

2.34

2.35

2.36

2.37

2.38

2.39

2.40



#### 3. java基础

##### 3.1   break 和 continue 的区别

```

   break， 跳出整个循环
   continue， 跳出当前某一个循环
```



##### 3.2  && 和 || 的使用

##### 3.3 String ,StringBuilder ,StringBuffer的区别

##### 3.4  JDK 各版本 新属性

https://www.cnblogs.com/ulong/p/10212823.html

```
1.7 ：

1.8 ：
接口有默认实现方法了，只需要使用 default关键字即可
Lambda 表达式
Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用

Optional 接口:

Optional<String> optional = Optional.of("bam");
optional.isPresent();           // true
optional.get();                 // "bam"
optional.orElse("fallback");    // "bam"

optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"

Stream 流:
并行Streams
Count 计数
Match 匹配
Map 映射
Sort 排序
Filter 过滤





DateTimeFormatter是不可变的，所以它是线程安全的
https://blog.csdn.net/dxhtostage/article/details/103905994




```

##### 3.5  JDK 1.7  和1.8版本 时间格式化的区别

https://blog.csdn.net/dxhtostage/article/details/103905994

```
SimpleDateFormat是线程不安全的，在并发环境下使用SimpleDateFormat；
DateTimeFormatter是线程安全的，jdk8自带（ java.time.format.DateTimeFormatter）；
Joda time里的DateTimeFormat也是线程安全。
```



##### 3.6 抽象类和接口的区别

##### 3.7 快速失败和安全失败

##### 3.8 i++ 和 ++i 的区别

##### 3.9 包装类Integer.valueof(""),使用了缓存

##### 3.10 类的封装性

```
private ， 同一类中可见
default,   同一包中的类
protect,   不同包中的子类
public ，所有
```

##### 3.11  类的多态性：

```
方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。

重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为 private 则子类中就不是重
```



##### 3.12 创建对象4种方式

```
  new
  clone
  反序列化
  反射机制
```



##### 3.13 final， finally，finalize的区别

##### 3.14 异常

```
1. 受检异常，IDEA 爆红，
2. 非受检异常

Exception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。
```

##### 3.15 匿名内部类

https://www.cnblogs.com/chenssy/p/3390871.html

```
     1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

     2、匿名内部类中是不能定义构造函数的。

     3、匿名内部类中不能存在任何的静态成员变量和静态方法。

      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

     5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
     
     
      我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。
```

##### 3.16 接口为啥不能有构造函数

```
接口存在的意义主要有两点：

禁止直接为其实例化对象
打破单继承局限（实现伪多重继承）

主要是因为其不能被实例化

```

##### 3.17 介绍一下Java中的IO流

##### 3.18 说一说NIO的实现原理

```
【得分点】

Buffer、Channel、Selector

【参考答案】

标准回答

NIO是基于IO多路复用模型的实现，它包含三个核心组件，分别是Buffer、Channel、Selector。

1. NIO是面向缓冲区的，在NIO中所有的数据都是通过缓冲区处理的。Buffer就是缓冲区对象，无论读取还是写入，数据都是先进入Buffer的。Buffer的本质是一个数组，通常它是一个字节数组，也可以是其他类型的数组。Buffer是一个接口，它的实现类有ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。

2. Channel是一个通道，可以通过它读取和写入数据。与流不同的是，流是单向的，而Channel是双向的。数据可以通过Channel读到Buffer里，也可以通过Channel写入到Buffer里。为了支持不同的设备，Channel接口有好几种子类，如FileChannel用于访问磁盘文件、SocketChannel和ServerSocketChannel用于TCP协议的网络通信、DatagramChannel用于UDP协议的网络通信。

3. Selector是多路复用器，可以通过它监听网络IO的状态。它可以不断轮询注册的Channel，如果某Channel上有连接、读取、写入事件发生，则这个Channel就处于就绪状态，就会被Selector轮询出来。所有被轮询出来的Channel集合，我们可以通过SelectionKey获取到，然后进行后续的IO操作。

加分回答

Buffer对象包含三个重要的属性，分别是capacity、position、limit。其中，capacity代表Buffer的容量，就是说Buffer中最多只能写入capacity个数据。position代表访问的位置，它的初始值为0，每读取/写入一个数据，它就会向后移动一个位置。limit代表访问限制，就是本次操作最多能读取/写入多少个数据。这三个属性的关系是，position<=limit<=capacity，Buffer通过不断调整position和limit的值，使得自身可以不断复用。

【延伸阅读】

Java NIO根据操作系统的不同，会对Selector做不同的实现。如Linux上的PollSelectorProvider、Windows上的WindowsSelectorProvider、MacOS上的KQueueSelectorProvider等。在使用Selector时，我们不需要指定哪一个实现，JDK会自动选择合适的Selector实现。
```

##### 3.19 说一说软链接和硬链接的区别

##### 3.20 面向对象的基本原则



```
这是面向对象编程的一种设计原则，对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。

单一职责原则 SRP(Single Responsibility Principle) 类的功能要单一，不能包罗万象，跟杂货铺似的。
开放封闭原则 OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。
里式替换原则 LSP(the Liskov Substitution Principle LSP) 子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~（其实多态就是一种这个原则的一种实现）。
接口分离原则 ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。
依赖倒置原则 DIP(the Dependency Inversion Principle DIP) ：高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。
抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。
比如说中国人是抽象的，下面有具体的 xx 省，xx 市，xx 县。你要依赖的抽象是中国人，而不是你是 xx 村的。
所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。
Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个「抽象」，也就是 Servlet 规范。
Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。
```



#### 4. java高级

##### 4.1 集合

######  解决冲突的方法：

https://www.jianshu.com/p/a343dae4a818

```
 链地址法
 再哈希法
 建立公共溢出区
 开放地址法
```



###### HashMap



https://www.bbsmax.com/A/qVde0aBp5P/

```
1.7 
数组+链表 
put 和 get 的过程：
首先判断集合是否为空，空的话进行初始化，否则根据传进来的key，进行hash，按位异或 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);高低位都进行计算，减少哈希冲突，
如果key为null，放到第一个key位置
如果集合不存在，直接插入
如果集合存在，

安全性，头插法，造成循环，CPU 100%

1.8 数组 + 链表 + 红黑树
 链表大于8的时候转为红黑树
 
 安全性，尾插法，数据覆盖导致不安全
 



```

###### currentHashMap



```
1.7 
sedment + ReetrantLock


```



###### get过程

###### put过程



###### size计算

```
众所周知，concurrenthashmap有很多歌segments，首先遍历segments将每个segment的count加起来作为整个concurrenthashMap的size。如果没有并发的情况下这自然就可以了，但这是多线程的，如果前脚统计完后脚有变化了，这就不准确了，源码中引入了，modCount和两次比较来实现size的确认。具体过程是：

1.进行第一遍遍历segments数组，将每个segemnt的count加起来作为总数，期间把每个segment的modCount加起来sum作为结果是否被修改的判断依据。
这里需要提一下modCount，这个是当segment有任何操作都会进行一次增量操作，代表的是对Segment中元素的数量造成影响的操作的次数，这个值只增不减！！！！只增不减很重要，这样就不会出现一个segment+1，导致modcount+1,而另一个segment-1，即modcount-1 ,从而在统计所有的时候modcount没有变化。

2.size操作就是遍历了两次所有的Segments，每次记录Segment的modCount值，然后将两次的modCount进行比较，如果相同，则表示期间没有发生过写入操作，就将原先遍历的结果返回，如果不相同，则把这个过程再重复做一次，如果再不相同，则就需要将所有的Segment都锁住，然后一个一个遍历了。

3.如果经判断发现两次统计出的modCount并不一致，那就如上所说，要重新启用全部segment加锁的方式来进行count的获取和统计了，这样在此期间每个segement都被锁住，无法进行其他操作，统计出的count自然很准确。

而之所以之所以要先不加锁进行判断，道理很明显，就是不希望因为size操作获取这么多锁，因为获取锁不光占用资源，也会影响其他线程对ConcurrentHash的使用，影响并发情况下程序执行的效率。使用锁要谨慎！

```

###### 说一说HashMap的扩容机制

【得分点】

  三个条件、翻倍扩容

【参考答案】

标准回答

  向HashMap中添加数据时，有三个条件会触发它的扩容行为：

\1. 如果数组为空，则进行首次扩容。

\2. 将元素接入链表后，如果链表长度达到8，并且数组长度小于64，则扩容。

\3. 添加后，如果数组中元素超过阈值，即比例超出限制（默认为0.75），则扩容。

  每次扩容时都是将容量翻倍，即创建一个2倍大的新数组，然后再将旧数组中的数组迁移到新数组里。由于HashMap中数组的容量为2^N，所以可以用位移运算计算新容量，效率很高。

加分回答

  在数据迁移时，为了兼顾性能，不会重新计算一遍每个key的哈希值，而是根据位移运算后（左移翻倍）多出来的最高位来决定，如果高位为0则元素位置不变，如果高位为1则元素的位置是在原位置基础上加上旧的容量。

  举个例子，来演示一下数据迁移时，元素在新数组里位置的判定。假设旧数组长度为16（00010000），则翻倍后新数组的长度为32（00100000）。我们从十进制数字上看不出什么，但是从二进制数字却可以看出二者的明显差别，即翻倍后新值的高位多了1。

  如果我们把这两个值作为掩码，对key的哈希值做按位与运算，就能求出最高位那一位的差异。如果这一位是0则该元素的位置不变，否则该元素的位置就在原位置基础上加16。这个方式很巧妙，它省略了重新计算哈希值的时间，同时新增出来的一位是0或1是随机的，这样就把产生冲突的节点均匀的分散到新的槽里了。

> hash & (16-1) = hash & 00001111
>
> hash & (32-1) = hash & 00011111

【延伸阅读】

  如下图，数据迁移的过程，可以参考槽15内的元素的迁移路线进行理解：

![img](https://uploadfiles.nowcoder.com/images/20210901/308571_1630484794282/A2D396C4A0609ED1B90F76553603F754)

另外，HashMap的扩容是通过resize()方法实现的，该方法的关键代码如下：

> final Node<K,V>[] resize() {
>
>   ...
>
>   // 迁移数据
>
>   if (oldTab != null) {
>
> ​    // 遍历旧的桶
>
> ​    for (int j = 0; j < oldCap; ++j) {
>
> ​      Node<K,V> e;
>
> ​      if ((e = oldTab[j]) != null) {
>
> ​        // 清空旧的槽
>
> oldTab[j] = null;
>
> ​        // 若节点没有后继节点
>
> ​        if (e.next == null)
>
> ​          // 孤立节点直接重算位置
>
> ​          newTab[e.hash & (newCap - 1)] = e;
>
> ​        // 若节点为树型节点
>
> ​        else if (e instanceof TreeNode)
>
> ​          // 将树中的节点拆分到新数组的低位和高位
>
> ​          ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
>
> ​        // 若节点为链表节点
>
> ​        else {
>
> ​          // 将链表中节点拆分到新数组的低位和高位
>
> ​          // 低位的头尾节点
>
> ​          Node<K,V> loHead = null, loTail = null;
>
> ​          // 高位的头尾节点
>
> ​          Node<K,V> hiHead = null, hiTail = null;
>
> ​          // 后继节点
>
> ​          Node<K,V> next;
>
> ​          // 迭代，分配节点位置。
>
> ​          do {
>
> ​            next = e.next;
>
> ​            // 追加到低位链表
>
> ​            if ((e.hash & oldCap) == 0) {
>
> ​              ...
>
> ​            }
>
> ​            // 追加到高位链表
>
> ​            else {
>
> ​              ...
>
> ​            }
>
> ​          } while ((e = next) != null);
>
> ​          // 低位链表位置不变
>
> ​          if (loTail != null) {
>
> ​            loTail.next = null;
>
> ​            newTab[j] = loHead;
>
> ​          }
>
> ​          // 高位链表是在原位置基础上加上旧的容量
>
> ​          if (hiTail != null) {
>
> ​            hiTail.next = null;
>
> ​            newTab[j + oldCap] = hiHead;
>
> ​          }
>
> ​        }
>
> ​      }
>
> ​    }
>
>   }
>
>   return newTab;
>
> }

##### 4.2 反射

###### 获取类对象

```
Class c1=User.class;

Class c2=u.getClass();

Class c3=Class.forName("com.forezp.User");
```

###### 获取类实例

```
User user=(User)c1.newInstance();
```



###### 获取类方法

```
getMethod()所有的 public方法，包括父类继承的 public

 getDeclaredMethods()获取该类所有的方法，包括private ,但不包括继承的方法。
```



###### 获取类属性

###### 获取类构造函数

```

public static void printConstructInfo(Object o){
        Class c=o.getClass();

        Constructor[] constructors=c.getDeclaredConstructors();
        for (Constructor con:constructors){
            System.out.print(con.getName()+"(");

            Class[] typeParas=con.getParameterTypes();
            for (Class class1:typeParas){
                System.out.print(class1.getName()+" ,");
            }
            System.out.println(")");
        }
    }


```

###### 实战

```
 public static void main(String[] args) {
        A a=new A();
        Class c=a.getClass();
        try {
            Method method=c.getMethod("add",new Class[]{int.class,int.class});
            //也可以 Method method=c.getMethod("add",int.class,int.class);
            //方法的反射操作
            method.invoke(a,10,10);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

```

###### 如何往一个List<int>里面插入一个String？

```
抛开实用性，我们只是简单的去探讨一下这个问题。
List<String>指定了添加到List的对象必须为String类型，范型约束的产生在编译阶段，那么我们是否能够绕过编译，在运行阶段添加一个int类型的数据呢，答案是肯定的。

        List<String> list1 = new ArrayList<>();
        list1.add("test1");
        // 添加int类型数据报错
        // list1.add(20);

        Class class2 = list1.getClass();
        try {
            Method method1 = class2.getMethod("add", Object.class);
            // 通过反射机制操作list1
            method1.invoke(list1, 20);

            // 输出结果[test1, 20]
            System.out.println(list1);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

作者：i左撇子
链接：https://www.jianshu.com/p/3fde9cdfb432
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 4.3 序列化

###### 定义

```
序列化： 将对象写入到IO流中
反序列化： 将IO流中恢复对象

对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化
方法、类变量、transient实例变量都不会被序列化。


【得分点】

序列化的作用、方式、规则

【参考答案】

标准回答

序列化机制可以将对象转换成字节序列，这些字节序列可以保存到磁盘上，也可以在网络中传输，并且程序可以将这些字节序列恢复成原来的对象。其中，序列化（Serialize）是指将一个Java对象写入IO流中，而反序列化（Deserialize）则是指从IO流中恢复这个Java对象。

如果对象要支持序列化机制，则它的类需要实现Serializable接口。该接口只是一个标记接口，它没有提供任何方法，只是用来标明该类是可以序列化的。在Java中很多类都已经实现了Serializable接口，比如包装类、String、Date等。

在实现序列化和反序列化的时候，我们需要使用ObjectInputStream和ObjectOutputStream这两个
LineIterator it = FileUtils.lineIterator(theFile, "UTF-8");

try {

while (it.hasNext()) {

String line = it.nextLine();

// do something with line

}

} finally {

LineIterator.closeQuietly(it);

}

流。其中，序列化时可以通过ObjectOutputStream的writeObject()输出对象序列，反序列化时可以通过ObjectInputStream的readObject()将序列恢复为对象。

加分回答

序列化的目的是将对象中的数据（成员变量）转为字节序列，和成员方法无关。为了正确地序列化某个对象，需要这个对象的类符合如下规则：

1. 该对象中引用类型的成员变量也必须是可序列化的。

2. 该类的直接或间接的父类，要么具有无参构造器，要么也是可序列化的。

3. 一个对象只会被序列化一次，再次序列化时仅仅会输出它的序列号而已。

【延伸阅读】

序列化与反序列化的示例如下：

/**

* 序列化

*/

public class IODemo {

public static void main(String[] args) {

testSerialize();

testDeserialize();

}

public static void testSerialize() {

try (

ObjectOutputStream oos = new ObjectOutputStream(

new FileOutputStream("C:/work/alpha/car.txt"));

) {

oos.writeObject(new Car("奔驰", "红色", 300));

oos.writeObject(new Car("宝马", "蓝色", 400));

oos.writeObject(new Car("奥迪", "黑色", 500));

} catch (FileNotFoundException e) {

e.printStackTrace();

} catch (IOException e) {

e.printStackTrace();

}

}


public static void testDeserialize() {

try (

ObjectInputStream ois = new ObjectInputStream(

new FileInputStream("C:/work/alpha/car.txt"));

) {

System.out.println(ois.readObject());

System.out.println(ois.readObject());

System.out.println(ois.readObject());

} catch (FileNotFoundException e) {

e.printStackTrace();

} catch (IOException e) {

e.printStackTrace();

} catch (ClassNotFoundException e) {

e.printStackTrace();

}

}

}

class Car implements Serializable {

private String brand;

private String color;

private int maxSpeed;

public Car(String brand, String color, int maxSpeed) {

System.out.println("Init Car.");

this.brand = brand;

this.color = color;

this.maxSpeed = maxSpeed;

}

public String getBrand() {

return brand;

}

public void setBrand(String brand) {

this.brand = brand;

}

public String getColor() {

return color;

}
public void setColor(String color) {

this.color = color;

}

public int getMaxSpeed() {

return maxSpeed;

}

public void setMaxSpeed(int maxSpeed) {

this.maxSpeed = maxSpeed;

}

@Override

public String toString() {

return "Car{" +

"brand='" + brand + '\'' +

", color='" + color + '\'' +

", maxSpeed=" + maxSpeed +

'}';

}

}



```

###### 使用场景

```
远程过程调用（RPC），所有在网络传输的对象必须是可序列化的
```

###### 序列化方式

```
实现Serializable接口

实现Externalizable接口，自定义
```



###### 序列化怎么保证升级前后的兼容性

```
private static final long serialVersionUID
```

###### 序列化的类型

```
JDK自带的，效率低

Google Protobuf

FaceBook
```

###### Serializable接口为什么需要定义serialVersionUID**常量**

```

```



##### 4.4 自旋锁的实现

https://blog.csdn.net/cxu123321/article/details/108789331

##### 4.5 限流算法的实现

##### 4.6 git 和SVN的区别

https://www.cnblogs.com/Sungeek/p/9152223.html

https://www.cnblogs.com/pawn-i/p/11898038.html



|                      | Git(分布式版本控制系统)                                      | Svn(集中式版本控制系统)                                      |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**             | Git是目前世界上最先进的分布式版本控制系统。                  | SVN是Subversion的简称，是一个开放源代码的版本控制系统，说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。 |
| **工作流程**         | ![img](https://img2018.cnblogs.com/blog/1079426/201911/1079426-20191120144835123-1031330889.png) 1.写代码2.提交到本地版本库3.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突4.将远程库与本地代码合并结果提交到本地版本库5.将本地版本库推到服务器 | ![img](https://img2018.cnblogs.com/blog/1079426/201911/1079426-20191120144959532-75082057.jpg)1.写代码2.从服务器拉回服务器的当前版本库，并解决服务器版本库与本地代码的冲突3.将本地代码提交到服务器 |
| **是否有中央服务器** | 没有中央服务器，开发人员本地都有 Local Repository            | 有。开发人员需要从中央服务器获得最新版本的项目然后在本地开发，开发完推送给中央服务器。因此脱离服务器开发者是几乎无法工作的 |
| **网络依赖 **        | 分布式在没有网络的情况下也可以执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push 到 Remote Repository。 | 必须要联网才能工作，而且对网络的依赖性较强，如果推送的文件比较大而且网络状况欠佳，则提交文件的速度会受到很大的限制。 |
| **文件存储格式**     | 按照元数据方式存储，体积很小                                 | 按照原始文件存储，体积较大                                   |
| **分支操作影响**     | 分支操作不会影响其他开发人员                                 | 创建新的分支则所有的人都会拥有和你一样的分支                 |
| **提交过程**         | 提交是本地操作，需要执行push操作才会到主要版本库             | 提交的文件会直接记录到中央版本库                             |
| **优势**             | 1.分布式管理：Git是没有中心服务器的，每个人机器上都是一个完整的库2.离线工作：（1）断网提交至本地库（2）本地回滚3.分支策略：在Git实际开发中分支的分离和合并是属于日常操作，开启和合并分支成本相比SVN要小得多：SVN是复制一份代码到分支目录，Git则是在分支点做一下标。 | 1.集中式管理，管理方式在服务端配置好，客户端只需要同步提交即可，使用方便，操作简单，很容易就可以上手2.在服务端统一控制好访问权限，利用代码的安全管理。3.所有的代码以服务端为准，代码一致性高。 |
| **缺点**             | 1.模式上比SVN更加复杂2.代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息 | 1.所有操作都需要通过服务端进行同步，这会导致服务器性能要求比较高。如果服务器宕机了就无法提交代码了。2.分支管理不灵活，svn分支是一个完整的目录，且这个目录拥有完整的实际文件，这些操作都是在服务端进行同步的，不是本地化操作，如果要删除分支，也是需要将远程的分支进行删除，这会导致大家都得同步3.需要连网，如果无法连接到服务器就无法提交代码 |



##### 4.7



4.8

4.9

4.10

4.11

4.12

41.3

4.14

4.15

4.16

4.17

4.18





#### 5. 多线程

##### 5.1 线程的生命周期

```
1. 初始
2. 就绪状态
3. 运行状态
4. 中断状态
5. 中止状态
```



##### 5.2  如何优化线程池



```
1. 设置其最大线程，最小线程数，IO密集型，2CPU ，cpu密集型：CPU+1

2. 设置线程的空闲时间，keepTimeAlive

3. 抛弃队列的选择
```



##### 5.3  为什么指令重[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)能优化代码执行速度

https://blog.csdn.net/weixin_37841366/article/details/113086438

```
重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。
```



##### 5.4 线程池原理

7**个核心参数**

```
核心线程数 

最大线程数

线程空闲时间

线程空闲时间单位

工作队列

抛弃策略

线程工厂
```

**原理**



```

```

##### 5.5 死锁

https://blog.csdn.net/guaiguaihenguai/article/details/80303835

**四个必须**

```
1. 相互互斥
2. 不可剥夺条件，只能线程自己释放资源
3. 循环等待
4. 占有并且等待
```



**预防死锁**

```
打破其四个必要条件：

1. 一次性申请所有资源，简单安全，但资源利用率低
2. 该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。
3.破坏“不可抢占”条件
      当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。
      该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。
4.破坏“循环等待”条件
     可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源
这样虽然避免了循环等待，但是这种方法是比较低效的，资源的执行速度回变慢，并且可能在没有必要的情况下拒绝资源的访问，比如说，进程c想要申请资源1，如果资源1并没有被其他进程占有，此时将它分配个进程c是没有问题的，但是为了避免产生循环等待，该申请会被拒绝，这样就降低了资源的利用率
```



**防止死锁**

```
    1、如果一个进程的请求会导致死锁，则不启动该进程
    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。
避免死锁的具体实现通常利用银行家算法
```

**死锁解除**

```
如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：
1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。
2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。
    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。
     b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：
    进程的优先级
    进程已运行时间以及运行完成还需要的时间
    进程已占用系统资源
    进程运行完成还需要的资源
    终止进程数目
    进程是交互还是批处理

```



##### 5.6  常见关键字

###### ThreadLocal

https://baijiahao.baidu.com/s?id=1663127810801876375&wfr=spider&for=pc

https://www.freesion.com/article/5698706089/

https://www.cnblogs.com/q540973436/p/13539021.html

https://juejin.cn/post/6844903878870171662 fastThreadLocal



https://blog.csdn.net/ol950919/article/details/108106533

```
底层结构： threadLocalMap
从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置。

ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，那么 ThreadLocalMap 中保存的 key 值就变成了 null，而 Entry 又被 threadLocalMap 对象引用，threadLocalMap 对象又被 Thread 对象所引用，那么当 Thread 一直不终结的话，value 对象就会一直存在于内存中，也就导致了内存泄漏，直至 Thread 被销毁后，才会被回收。

fastThreadLocal 是 ThreadLocal 的替代品，吞吐量更快，内部实现了自动删除，不会存在内存泄露

InheritableThreadLocal

```



```
public class Test {
    public static InheritableThreadLocal threadLocal = new InheritableThreadLocal();
    public static void main(String[] args) throws Exception{
        threadLocal.set("主线程的值");
        System.out.println(threadLocal.get());
        Thread.sleep(3000);
        new Thread( ()-> {
            threadLocal.set("子线程的值");
            System.out.println(threadLocal.get());
        }).start();
        Thread.sleep(3000);
        System.out.println(threadLocal.get());
    }
}

InheritableThreadLocal关键字中子线程会继承父线程存储的数据。子线程可以修改继承的主线程的存储数据，且主线程的存储数据不受影响。

```



###### synchronize



```
底层原理：monitorenter monitorexit


对象头： Hash,分代年龄，锁标志，01,01,00,10  无锁，偏向锁，轻量级锁，重量级锁

同步代码快
同步方法 ACC_SYNCHRONIZED
同步对象



```

```
【得分点】

对象头、锁升级

【参考答案】

标准回答

synchronized的底层是采用Java对象头来存储锁信息的，并且还支持锁升级。

Java对象头包含三部分，分别是Mark Word、Class Metadata Address、Array length。其中，Mark Word用来存储对象的hashCode及锁信息，Class Metadata Address用来存储对象类型的指针，而Array length则用来存储数组对象的长度。如果对象不是数组类型，则没有Array length信息。synchronized的锁信息包括锁的标志和锁的状态，这些信息都存放在对象头的Mark Word这一部分。

Java 6为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁。所以，在Java 6中，锁一共被分为4种状态，级别由低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。随着线程竞争情况的升级，锁的状态会从无锁状态逐步升级到重量级锁状态。锁可以升级却不能降级，这种只能升不能降的策略，是为了提高效率。

synchronized的早期设计并不包含锁升级机制，所以性能较差，那个时候只有无锁和有锁之分。是为了提升性能才引入了偏向锁和轻量级锁，所以需要重点关注这两种状态的原理，以及它们的区别。

偏向锁，顾名思义就是锁偏向于某一个线程。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程再进入和退出同步块时就不需要做加锁和解锁操作了，只需要简单地测试一下Mark Word里是否存储着自己的线程ID即可。

轻量级锁，就是加锁时JVM先在当前线程栈帧中创建用于存储锁记录的空间，并将Mark Word复制到锁记录中，官方称之为Displaced Mark Word。然后线程尝试以CAS方式将Mark Word替换为指向锁记录的指针，如果成功则当前线程获得锁，如果失败则表示其他线程竞争锁，此时当前线程就会通过自旋来尝试获取锁。

加分回答

下面，我们再从实际场景出发，来具体说说锁升级的过程。

\1. 一开始，没有任何线程访问同步块，此时同步块处于无锁状态。

\2. 然后，线程1首先访问同步块，它以CAS的方式修改Mark Word，尝试加偏向锁。由于此时没有竞争，所以偏向锁加锁成功，此时Mark Word里存储的是线程1的ID。

\3. 然后，线程2开始访问同步块，它以CAS的方式修改Mark Word，尝试加偏向锁。由于此时存在竞争，所以偏向锁加锁失败，于是线程2会发起撤销偏向锁的流程（清空线程1的ID），于是同步块从偏向线程1的状态恢复到了可以公平竞争的状态。

\4. 然后，线程1和线程2共同竞争，它们同时以CAS方式修改Mark Word，尝试加轻量级锁。由于存在竞争，只有一个线程会成功，假设线程1成功了。但线程2不会轻易放弃，它认为线程1很快就能执行完毕，执行权很快会落到自己头上，于是线程2继续自旋加锁。

\5. 最后，如果线程1很快执行完，则线程2就会加轻量级锁成功，锁不会晋升到重量级状态。也可能是线程1执行时间较长，那么线程2自旋一定次数后就放弃自旋，并发起锁膨胀的流程。届时，锁被线程2修改为重量级锁，之后线程2进入阻塞状态。而线程1重复加锁或者解锁时，CAS操作都会失败，此时它就会释放锁并唤醒等待的线程。

总之，在锁升级的机制下，锁不会一步到位变为重量级锁，而是根据竞争的情况逐步升级的。当竞争小的时候，只需以较小的代价加锁，直到竞争加剧，才使用重量级锁，从而减小了加锁带来的开销。
```

【延伸阅读】

Java对象头结构如下所示：

![img](https://uploadfiles.nowcoder.com/images/20210901/308571_1630485164398/04AC7C263A24A150500B953E1C290609)

Mark Word默认结构如下所示（32位）：

![img](https://uploadfiles.nowcoder.com/images/20210901/308571_1630485182073/E318A7296F017D110C4B99375C9ACE78)

Mark Word在锁升级中演化结构如下所示（32位）：

![img](https://uploadfiles.nowcoder.com/images/20210901/308571_1630485188442/8CBF8B629EABB6ED0C334EFFF24CFCF8)

升级偏向锁的过程如下图：

![img](https://uploadfiles.nowcoder.com/images/20210901/308571_1630485195345/B71E11C6999AA8A2CF03889E4211589B)

升级轻量级锁的过程如下图：

![img](https://uploadfiles.nowcoder.com/images/20210901/308571_1630485203310/73AA472D90494FE89805448A63352C97)

###### volitale

https://www.jianshu.com/p/ef8de88b1343 内存屏障

```
只能保证可见性，顺序性，不能保证原子性

　　volatile很好的保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，但是加了这个指令后，会引发两件事情：

　　将当前处理器缓存行的数据写回到系统内存
　　这个写回内存的操作会使得在其他处理器缓存了该内存地址无效什么意思呢？意思就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。
　　
　　顺序性，是通过内存屏障来实现的

```



###### ReetrancLock



##### 5.7 为什么要线程同步,说出线程同步的几种方法



```
线程有可能和其他线程共享一些资源，比如，内存，文件，数据库等。
当多个线程同时读写同一份共享资源的时候，可能会引起冲突。这时候，我们需要引入线程“同步”机制，即各位线程之间要有个先来后到，不能一窝蜂挤上去抢作一团。
线程同步的真实意思和字面意思恰好相反。线程同步的真实意思，其实是“排队”：几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。

线程同步的方法
(1)wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
(2)sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉  
  InterruptedException异常。
(3)notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的
  唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
(4)notityAll ():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，
  而是让它们竞争
```



```
1. 互斥锁（Mutex）

互斥量是最简单的同步机制，即互斥锁。多个进程(线程)均可以访问到一个互斥量，通过对互斥量加锁，从而来保护一个临界区,防止其它进程(线程)同时进入临界区，保护临界资源互斥访问。

2. 条件变量（condition variable）

条件变量适合多个进程(线程)等待同一事件发生，然后去干某事。举一个简单的例子：

生产者和消费者模型：
多个消费者去等待生产者生产物品，消费者去消耗物品。当生产者生产出来一件物品时，便可以通知所有的消费者(当然也可以只通知其中一个等待的消费者)---可以去消耗物品了。这时多个消费者便去争抢物品，谁快谁拿到物品消耗。当物品被消耗完时，消费者就等待生产者。就类似于这样的场景。
条件变量必须配合互斥量一起工作。为什么？因为生产者生产出来的物品是临界资源，即所有进程和线程都可以使用的公共资源，则在一个时刻仅允许一个消费者去取。这时便使用互斥量去保护临界资源。
3. 读写锁（reader-writer lock）

读写锁适合于使用在读操作多，写操作少的情况，比如数据库。读写锁读锁可以同时加很多，但是写锁是互斥的。当有进程或者线程要写时，必须等待所有的读进程或者线程都释放自己的读锁方可以写。数据库很多时候可能只是做一些查询。

4. 信号量（semaphore）

在生产者消费者模型中，对任务数量的记录就可以使用信号量来做。可以理解为带计数的条件变量。当信号量的值小于0时，工作进程或者线程就会阻塞，等待物品到来。当生产者生产一个物品，会将信号量值加1操作。 这是会唤醒在信号量上阻塞的进程或者线程，它们去争抢物品。
```

##### 5.8 ABA问题怎么解决

```
CAS操作可能带来ABA问题，因为CAS操作需要在操作值的时候，检查值有没有发生变化，如果没有发发生变化则更新。如果一个值原理是A，变成了B，又变成了A，那么使用CAS进行检查时会认为它的值没有变化，但是实际上却变了。

ABA问题的解决办法就是使用版本号，在变量前面追加版本号，每次变量更新时把版本号加1，那么A-B-A就会变成1A-2B-3A。

从jdk1.5开始，jdk中的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果都相等，则以原子方式将该引用和标志的值设为给定的更新值。
————————————————
版权声明：本文为CSDN博主「向程序猿进化」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lm1060891265/article/details/81747510
```

5.9

5.10

5.11

5.12

5.13

5.14

5.15

5.16

5.17

5.18

5.19



#### 6. Spring

##### 6.1 IOC

```
1. 控制反转
以前我们要生成一个对象，需要自己去new，使用IOC的话需要什么对象直接在告诉spring容器我需要什么，容器负责生产分配对象给你；

2. 依赖注入

```



##### 6.2 AOP



https://zhuanlan.zhihu.com/p/73189840

```
一. 概念

aop可以看做是横向的代码重用，日志，权限校验

1. 切面

2. 切点：

被增强的连接点是切入点。没被增强的是连接点但不是切入点。



3. 连接点：

被增强的方法是连接点也叫切入点(某一类的里面的所有方法)，增强（Advice）内容里面的方法都是连接点，也存在是连接点，但不是切入点的情况。就是没被增强的方法，就不是切入点。

4. 增强

就相当于你走到切入点了，然后你告诉切入点“不行！刚刚用拳头打的不过瘾，我要用锤子“增强”一下。”这个顺便要做的事情就是增强。

1.前置增强：就是在被增强方法执行前执行

2.后置增强：被增强方法执行后紧接着执行

3.异常增强：爆出异常时候执行（后置增强和异常增强二者只能执行一个）

4.最终增强：最终一定会执行的增强也是最后执行。

5. 织入

织入说白了就是将切面与切入点结合这是个逻辑过程，AOP有三种织入的方式：

a、编译期织入，这要求使用特殊的Java编译器。

b、类装载期织入，这要求使用特殊的类装载器。

c、动态代理织入，在运行期为目标类添加增强生成子类的方式。

二. 实现方式

  JDK 动态代理接口
  
  cglib,字节码方式，生产其子类
  
三，区别
  
java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。

而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 

3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换

如何强制使用CGLIB实现AOP？
 （1）添加CGLIB库，SPRING_HOME/cglib/*.jar
 （2）在spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class="true"/>

JDK动态代理和CGLIB字节码生成的区别？
 （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类
 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
   因为是继承，所以该类或方法最好不要声明成final 



```



https://www.cnblogs.com/leifei/p/8263448.html

用户管理接口

```
package com.lf.shejimoshi.proxy.entity;
//用户管理接口
public interface UserManager {
    //新增用户抽象方法
    void addUser(String userName,String password);
    //删除用户抽象方法
    void delUser(String userName);
    
}
```



用户管理接口实现类

```
package com.lf.shejimoshi.proxy.entity;
//用户管理实现类,实现用户管理接口
public class UserManagerImpl implements UserManager{
    //重写新增用户方法
    @Override
    public void addUser(String userName, String password) {
        System.out.println("调用了新增的方法！");
        System.out.println("传入参数为 userName: "+userName+" password: "+password);
    }
    //重写删除用户方法
    @Override
    public void delUser(String userName) {
        System.out.println("调用了删除的方法！");
        System.out.println("传入参数为 userName: "+userName);
    }
    
}
```



JDK动态代理

```
package com.lf.shejimoshi.proxy.jdk;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

import com.lf.shejimoshi.proxy.entity.UserManager;
import com.lf.shejimoshi.proxy.entity.UserManagerImpl;
//JDK动态代理实现InvocationHandler接口
public class JdkProxy implements InvocationHandler {
    private Object target ;//需要代理的目标对象
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("JDK动态代理，监听开始！");
        Object result = method.invoke(target, args);
        System.out.println("JDK动态代理，监听结束！");
        return result;
    }
    //定义获取代理对象方法
    private Object getJDKProxy(Object targetObject){
        //为目标对象target赋值
        this.target = targetObject;
        //JDK动态代理只能针对实现了接口的类进行代理，newProxyInstance 函数所需参数就可看出
        return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this);
    }
    
    public static void main(String[] args) {
        JdkProxy jdkProxy = new JdkProxy();//实例化JDKProxy对象
        UserManager user = (UserManager) jdkProxy.getJDKProxy(new UserManagerImpl());//获取代理对象
        user.addUser("admin", "123123");//执行新增方法
    }
    
}
```



Cglib动态代理（需要导入两个jar包，asm-5.2.jar,cglib-3.2.5.jar。版本自行选择）

```
package com.lf.shejimoshi.proxy.cglib;

import java.lang.reflect.Method;

import com.lf.shejimoshi.proxy.entity.UserManager;
import com.lf.shejimoshi.proxy.entity.UserManagerImpl;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

//Cglib动态代理，实现MethodInterceptor接口
public class CglibProxy implements MethodInterceptor {
    private Object target;//需要代理的目标对象
    
    //重写拦截方法
    @Override
    public Object intercept(Object obj, Method method, Object[] arr, MethodProxy proxy) throws Throwable {
        System.out.println("Cglib动态代理，监听开始！");
        Object invoke = method.invoke(target, arr);//方法执行，参数：target 目标对象 arr参数数组
        System.out.println("Cglib动态代理，监听结束！");
        return invoke;
    }
    //定义获取代理对象方法
    public Object getCglibProxy(Object objectTarget){
        //为目标对象target赋值
        this.target = objectTarget;
        Enhancer enhancer = new Enhancer();
        //设置父类,因为Cglib是针对指定的类生成一个子类，所以需要指定父类
        enhancer.setSuperclass(objectTarget.getClass());
        enhancer.setCallback(this);// 设置回调 
        Object result = enhancer.create();//创建并返回代理对象
        return result;
    }
    
    public static void main(String[] args) {
        CglibProxy cglib = new CglibProxy();//实例化CglibProxy对象
        UserManager user =  (UserManager) cglib.getCglibProxy(new UserManagerImpl());//获取代理对象
        user.delUser("admin");//执行删除方法
    }
    
}
```



##### 6.3 生命周期

```

```



##### 6.4  三级缓存

https://www.cnblogs.com/semi-sub/p/13548479.html

##### 6.5 SpringMVC



```

```



##### 6.6 Spring 拓展点

https://baijiahao.baidu.com/s?id=1679178070358092034&wfr=spider&for=pc

```
1. Bean定义时扩展
BeanDefinitionRegistryPostProcessor

2. BeanFactoryPostProcessor
在BeanFactory生成之后，通过该接口自定义修改应用程序上下文的BeanDefinition，调整上下文的BeanFactory的bean属性值。

3. 
```



##### 6.7 如何实现一个starter

##### 6.8 Spring boot 自动装配原理

```
Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。
加分回答

@EnableAutoConfiguration的作用是，从classpath中搜索所有的spring.factories配置文件，然后将其中的配置项加载到spring容器。只有spring.boot.enableautoconfiguration参数为true（默认为true）的时候，才启用自动配置。@EnableAutoConfiguration还可以根据class来排除，或是根据class name来排除，其内部实现的关键点有：

1. ImportSelector：该接口的方法的返回值都会被纳入到spring容器管理中；

2. SpringFactoriesLoader：该类可以从classpath中搜索所有spring.factories配置文件，并读取配置
```

##### 6.9 谈谈你对spring boot 理解

```
【得分点】

与Spring的关系 、核心功能 、优点

【参考答案】

标准回答

Spring Boot本身并不提供Spring的核心功能，而是作为Spring框架的脚手架框架，以达到快速构建项目，预置第三方配置，开箱即用的目的。

Spring Boot 核心功能：

1. 自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置。

2. 起步依赖：Spring Boot通过起步依赖为项目的依赖管理提供帮助。起步依赖其实就是特殊的Maven依赖和Gradle依赖，利用了传递依赖解析，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。

3. 端点监控：Spring Boot 可以对正在运行的项目提供监控。

Spring Boot 优点如下：

· 可以快速构建项目；

· 可以对主流开发框架的无配置集成；

· 项目可独立运行，无需外部依赖Servlet容器；

· 提供运行时的应用监控；

· 可以极大地提高开发、部署效率；

· 可以与云计算天然集成。

加分回答

其实从本质上来说，Spring Boot就是Spring，它帮你完成了一些Spring Bean配置。Spring Boot使用“习惯优于配置”的理念让你的项目快速地运行起来，使用Spring Boot能很快的创建一个能独立运行、准生产级别、基于Spring框架的项目。

【延伸阅读】

Spring Boot常用注解：

1. @SpringBootApplication

在Spring Boot入口类中，唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解，用于开启自动配置，准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。

2. @EnableAutoConfiguration

@EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置，它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中。

3. @Import

@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。

4. @Conditional

@Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制Bean实例化的行为。

5. @Conditional衍生注解

在Spring Boot的autoconfigure项目中提供了各类基于@Conditional注解的衍生注解，它们适用不同的场景并提供了不同的功能。通过阅读这些注解的源码，你会发现它们其实都组合了@Conditional注解，不同之处是它们在注解中指定的条件（Condition）不同。常见的衍生注解如下：

o @ConditionalOnBean：在容器中有指定Bean的条件下。

o @ConditionalOnClass：在classpath类路径下有指定类的条件下。

o @ConditionalOnMissingBean：当容器里没有指定Bean的条件时。

o @ConditionalOnMissingClass：当类路径下没有指定类的条件时。
```



#### 7. 微服务

##### 7.1 SOA和微服务的区别

##### 7.2 RPC原理

##### 7.3 zookeeper 分布式锁

```
使用临时顺序节点
```

##### 7.4 zookeeper 节点类型

```
持久节点
临时节点
临时顺序节点
```

##### 7.5 大事务怎么解决

```
1. 少用@Transactional注解
2. 将查询(select)方法放到事务外
3. 事务中避免远程调用
4. 事务中避免一次性处理太多数据
5. 非事务执行
6. 异步处理



```

7.6

7.7

7.8

7.9

7.10

7.11

7.12



#### 8. 数据库

##### 8.1 Myisam  和 Inodb的区别

##### 8.2 Inodb 的底层原理

##### 8.3 mysql 的执行过程

##### 8.4 事务

###### 事务的四个特性：

```

1. 一致性
2. 隔离性
3. 持久性
4. 原子性

```



###### 事务隔离级别

```
1. 读未提交 RU ， 脏读，不可重复读，幻读
2. 读已提交 RC ， 不可重复读， 幻读
3. 可重复读 RR ， 幻读
4. 串行化
```



###### 多版本控制MVCC

```
快照读
当前读
readview undo 日志 ，读已提交，生成新的快照，可重复读。只用第一个快照

```



##### 8.5 索引 

###### 索引类别

```
1. 聚簇索引
2. 非聚簇索引
3. 覆盖索引
4. 辅助索引
5. 组合索引
6. 

```

###### 索引原理B+树

```

```



##### 8.6 日志

https://www.cnblogs.com/wy123/p/8365234.html

###### 说一说你对redo log、undo log、bin log的了解 

```
MySQL中有六种日志文件，
分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。
其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。
这里简单总结一下这三者具有一定相关性的日志。

重做日志（redo log）

作用：
　　确保事务的持久性。
　　防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
内容：
　　物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。
什么时候产生：
　　事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
什么时候释放：
　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。
对应的物理文件：
　　默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&ib_logfile2
　　innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。
　　innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2
　　关于文件的大小和数量，由一下两个参数配置
　　innodb_log_file_size 重做日志文件的大小。
　　innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1
其他：
　　很重要一点，redo log是什么时候写盘的？前面说了是在事物开始之后逐步写盘的。
　　之所以说重做日志是在事务开始之后逐步写入重做日志文件，而不一定是事务提交才写入重做日志缓存，
　　原因就是，重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。
　　
　　　　然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘
　　1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。
　　2，每个事务提交时会将重做日志刷新到重做日志文件。
　　3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件
　　由此可以看出，重做日志通过不止一种方式写入到磁盘，尤其是对于第一种方式，Innodb_log_buffer到重做日志文件是Master Thread线程的定时任务。
　　因此重做日志的写盘，并不一定是随着事务的提交才写入重做日志文件的，而是随着事务的开始，逐步开始的。
　　另外引用《MySQL技术内幕 Innodb 存储引擎》（page37）上的原话：
　　即使某个事务还没有提交，Innodb存储引擎仍然每秒会将重做日志缓存刷新到重做日志文件。
　　这一点是必须要知道的，因为这可以很好地解释再大的事务的提交（commit）的时间也是很短暂的。
　　
　　
　　
　　回滚日志（undo log）

作用：
　　保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

内容：
　　逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。

什么时候产生：
　　事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性

什么时候释放：
　　当事务提交之后，undo log并不能立马被删除，
　　而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。

对应的物理文件：
　　MySQL5.6之前，undo表空间位于共享表空间的回滚段中，共享表空间的默认的名称是ibdata，位于数据文件目录中。
　　MySQL5.6之后，undo表空间可以配置成独立的文件，但是提前需要在配置文件中配置，完成数据库初始化后生效且不可改变undo log文件的个数
　　如果初始化数据库之前没有进行相关配置，那么就无法配置成独立的表空间了。
　　关于MySQL5.7之后的独立undo 表空间配置参数如下
　　innodb_undo_directory = /data/undospace/ --undo独立表空间的存放目录
　　innodb_undo_logs = 128 --回滚段为128KB
　　innodb_undo_tablespaces = 4 --指定有4个undo log文件

　　如果undo使用的共享表空间，这个共享表空间中又不仅仅是存储了undo的信息，共享表空间的默认为与MySQL的数据目录下面，其属性由参数innodb_data_file_path配置。
　　
　　
　　其他：
　　undo是在事务开始之前保存的被修改数据的一个版本，产生undo日志的时候，同样会伴随类似于保护事务持久化机制的redolog的产生。
　　默认情况下undo文件是保持在共享表空间的，也即ibdatafile文件中，当数据库中发生一些大的事务性操作的时候，要生成大量的undo信息，全部保存在共享表空间中的。
　　因此共享表空间可能会变的很大，默认情况下，也就是undo 日志使用共享表空间的时候，被“撑大”的共享表空间是不会也不能自动收缩的。
　　因此，mysql5.7之后的“独立undo 表空间”的配置就显得很有必要了。

二进制日志（binlog）：

作用：
　　1，用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
　　2，用于数据库的基于时间点的还原。
内容：
　　逻辑格式的日志，可以简单认为就是执行过的事务中的sql语句。
　　但又不完全是sql语句这么简单，而是包括了执行的sql语句（增删改）反向的信息，
　　也就意味着delete对应着delete本身和其反向的insert；update对应着update执行前后的版本的信息；insert对应着delete和insert本身的信息。
　　在使用mysqlbinlog解析binlog之后一些都会真相大白。
　　因此可以基于binlog做到类似于oracle的闪回功能，其实都是依赖于binlog中的日志记录。

什么时候产生：
　　事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。
　　这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。
　　因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。
　　这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。

什么时候释放：
　　binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。
　　
　　　

其他：
　　二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同
　　1，作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。
　　2，内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句
　　3，另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。
　　4，恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog

　　关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，
　　MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。
　　
　　


```



##### 8.7  意向锁

```
我认为, 对表加锁时, 不但要感知当前表的加锁情况, 还要感知表中所有行的加锁情况, 才能判定是否能加锁成功, 但是对行加锁情况感知需要遍历每一行才行, 效率低. 所以引入意向锁. 这样, 添加行锁时, 自动添加意向锁,  添加表锁时, 也仅需要感知当前表是否有锁或意向锁就ok了, 不需要再遍历每一行去感知加锁情况.

意向锁是表锁

链接：https://www.zhihu.com/question/51513268/answer/438706734


select * from user where name = "libis" for update; 其中name字段不是user表的索引 这些情况下InnoDB都会上表锁。 那问题就来了，如果事务A正在修改user表的某条记录，事务B正好执行 select * from user where name = "libis" for update；事务B会得到执行吗？读者可以验证一下，事务B会被夯住，下图是事务B被夯住的情况，其中trx_id（ 14376 ）被14378阻塞： 

为什么会这样？那可以这样想，如果事务B不会被事务A阻塞，会发生什么？假设事务B没有被事务A阻塞，事务B先执行了一次  select * from user where name = "libis" for update得到了一行记录，此时事务A正好了修改了这条记录，然后提交了，事务B再次执行上述select语句就肯定会得到不同的记录，这就违背了事务隔离性的要求。意向锁就是为了解决这样的问题。事务A修改user表的记录r，会给记录r上一把X行锁，同时会给user表上一把意向排他锁（IX），这时事务B要给user表上表级排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。
```

##### 

##### 8.8 间隙锁

##### 8.9 索引下推

https://zhuanlan.zhihu.com/p/121084592

（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。

```
select * from user where name = "小明" and age = 12

其中 name 加了索引， 没有使用了索引下推，会先查询 等于小明的 id,再去查询 age
回表了两次

如果没有索引下推优化（或称ICP优化），当进行索引查询时，首先根据索引来查找记录，然后再根据where条件来过滤记录；在支持ICP优化后，MySQL会在取出索引的同时，判断是否可以进行where条件过滤再进行索引查询，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。



开启关闭命令：

set optimizer_switch='index_condition_pushdown=off';

```

##### 8.10  建索引要注意哪些事项

##### 8.11  kafka的文件结构

##### 8.12 InnoDB中的行级锁是怎么实现的 

##### 8.13 什么是ChangeBuffer

https://cloud.tencent.com/developer/article/1624144

```
问题前要:对于一个字段,它的更新操作很频繁,那么应该使用普通索引还是唯一索引?
结论：
如果业务能够保证唯一性应该尽量选择普通索引而不是唯一索引
从查询和更新两方面说明：

查询的性能差不多

更新的话：

change buffer是用来记录更新操作的一种行为，在没有把数据项从硬盘读取到内存中时，进行更新操作会先将操作记录的change buffer中
在下一次进行select的时候在把数据项读取到内存中时，会对数据项执行change buffer中的命令，这个过程也成为merge
所以唯一索引的更新操作往往是这样，首先判断要插入的项在数据库中存不存在，这里就涉及到了一个读的问题，往往这个时候就会把数据从硬盘读取到内存中，如果这个时候还使用change buffer的意义并不大
因为change buffer存在的意义就是减少磁盘于内存的IO，现在数据项已经在内存中了，可以直接修改，所以唯一索引是不适用change buffer的
普通索引的更新操作
普通索引往往是将操作记录到change buffer中，在下一次读取的时候执行这些操作，可以显著减少磁盘与内存的IO操作，从而提高效率

选择：
如果是读取远大于更新和插入的表，唯一索引和普通索引都可以，但是如果业务需求相反，个人觉得应该使用普通索引，当然如果是那种更新完要求立即可见的需求，就是刚更新完就要再查询的，这种情况下反而不推荐普通索引，因为这样会频繁的产生merge操作，起不到change buffer的作用，反而需要额外空间来维护change buffer就有点得不偿失了
```

##### 8.14 元数据锁（Metadata Lock 简称MDL）

https://www.cnblogs.com/ging/p/13467816.html

```

```



#### 9.  设计模式



##### 9.1 单列模式

```
单例模式，防止反射和反序列化漏洞：

修改构造函数：
	private SingletonDemo6() {
		// 防止反射获取多个对象的漏洞
		if (null != instance) {
			throw new RuntimeException();
		}
	}

```



**懒汉模式**

```
 public class Singleton{
 
    private static volitale Singleton instance;
    
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
    
          if(instance == null){
          
              synchronized( Singleton.class){
              
                 if(instance == null){
                 
                    instance = new Singleton();
                 
                 }
              }
          
          }
               return instance;
    }
 
 }
```



**恶汉模式**

```
public class Singleton{

     private static Singleton instance = new Singleton();
     
     private Singleton(){
     
     }
     
     public static Singleton getInstance(){
     
            return instance;
     }

}
```



**静态内部类**



```
  public class Singleton{
  
    private static class SingletonHolder {
    
      private static final Singleton instance = new Singleton();
    
    }
    
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
    
        return SingletonHolder.instance;
    }
  
  }
```



**枚举**





##### 9.2 策略模式



```

```



##### 9.3 适配器模式



```

```



##### 9.4 模板模式

```

```



##### 9.5 原型模式

##### 9.6 观察者模式

##### 9.7

##### 9.8





#### 10. 算法

![img](https://img-blog.csdn.net/20170406122131723)

##### 10.1 反转链表

​    **迭代法**

```
public class Solution{

    public ListNode reverseList(ListNode head){
    
            ListNode next = null;
            ListNode pre = null;
            
            while(head != null){
            
                next = head.next;
                head.next = pre;
                pre = head;
                head = next;
            
            }
           
           return pre;
    
    }

}
```



  **递归法**

```
class Solution {
    public ListNode reverseList(ListNode head) {
        return recur(head, null);    // 调用递归并返回
    }
    private ListNode recur(ListNode cur, ListNode pre) {
        if (cur == null) return pre; // 终止条件
        ListNode res = recur(cur.next, cur);  // 递归后继节点
        cur.next = pre;              // 修改节点引用指向
        return res;                  // 返回反转链表的头节点
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/UHnkqh/solution/jian-zhi-offer-ii-024-fan-zhuan-lian-bia-m8go/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.2 链表是否有环



**快慢指针**

```
public class Solution{

     public boolean hasCycle(ListNode head){
              
              ListNode fast = head;
              ListNode slow = head
     
            while(fast null && fastxt != null){
            
                   fast = fast.next.next;
                   slow = slow.next;
                    
                    if(fast == slow){
                    
                        return true;
                    
                    }
            
            }
     
          return false;
     }

}
```



##### 10.3  二叉树前中后序遍历

中序

```

（1）先(根)序遍历（根左右）

（2）中(根)序遍历（左根右）

（3）后(根)序遍历（左右根）


import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 *   public TreeNode(int val) {
 *     this.val = val;
 *   }
 * }
 */

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型一维数组
     */
    public int[] inorderTraversal (TreeNode root) {
        // write code here
        List<Integer> list = new ArrayList<Integer>();
        inOrder(root,list);
          int[] res = new int[list.size()];
        for(int i=0;i<list.size();i++){
            res[i] = list.get(i);
        }
        return res;
    }
    
    public  List<Integer> inOrder( TreeNode root , List<Integer> list){
        
        if( root != null){
            
            inOrder( root.left , list);
            list.add( root.val);
            inOrder( root.right,list);
          
        }
        
          return list;
    }
}
}
```





##### 10.4 二叉树层序遍历



**队列，先进先出**

```
public class Solution{

      public List<List<Integer>> leverOrder(TreeNode root){
      
              List<List<Integer>> res = new ArrayList<List<Integer>>();
      
              LinkerList<TreeNode> queue = new LinkerList<TreeNode>();
              
              queue.add(rooot.val);
              
              while(queue.size()!=0){
              
                  List<Integer> temp = new ArrayList<Integer>();
                  
                  for(int i=0 ;i<queue.size() ;i++){
                  
                      TreeNode  t = queue.remove();
                      temp.add(t.val);
                      if(t.left != null){
                      
                         queue.add(t.left);
                      }
                  
                      if(t.right != null){
                      
                         queue.add(t.right);
                      }
                  }
                  
                  res.add(ttemp);
              
              
              }
              
              return res;
      }

}
```



```
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        //边界条件判断
        if (root == null)
            return new ArrayList<>();
        //队列
        Queue<TreeNode> queue = new LinkedList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        //根节点入队
        queue.add(root);
        //如果队列不为空就继续循环
        while (!queue.isEmpty()) {
            //BFS打印，levelNum表示的是每层的结点数
            int levelNum = queue.size();
            //subList存储的是每层的结点值
            ArrayList<Integer> subList = new ArrayList<>();
            for (int i = 0; i < levelNum; i++) {
                //出队
                TreeNode node = queue.poll();
                subList.add(node.val);
                //左右子节点如果不为空就加入到队列中
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            //把每层的结点值存储在res中，
            res.add(subList);
        }
        return res;
    }
```



##### 10.5 用栈实现队列



```
  public class Solution{
  
       Stack<Integer> A = new Stack<Integer>();
       Stack<Integer> B = new Stack<Integer>();
       
       public void push(int node){
       
             A.push(node);
       
       }
       
       public int pop(){
       
           if(B.size()<= 0){
           
             while( A.size() != 0){
             
                B.push(A.pop());
             }
           }
           
           return B.pop();
       }
  
  }
```





##### 10.6  两数之和



```
  public class Solution{
  
       public int[] twoSum(int[] nums, int target){
       
       
              Map<Integer,Integer> map = new HashMap<Integer,Integer>();
              
              for(int i=0; i< nums.length-1 ;i++)
              {
                   if(map.containsKey(target-nums[i])){
                   
                      return new int[]{map.get(target-nums[i],i)};
                   
                   }else{
                   
                      map.put(nums[i],i)
                   }

              }
       
       
       }
  
  
  }
```



##### 10.7 整数反转



```
   public class Solution{
   
        pubblic int reverseInt(int x){
        
             int res = 0;
             while(x != 0){
             
                 int temp = x / 10 + res * 10;
                 
                 res = temp;
                 x /= 10;
             
             }
             
             return res;
        
        }
   
   
   }
```



##### 10.8  从尾到头打印链表

https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/xie-liao-na-yao-duo-ci-zong-jie-san-chon-exv5/

```
   public class Solution{
   
        public int[] reverseList(ListNode head){
        
         Stack<Integer> stack = new Stack<Integer>();
         
           while(head != null){
           
                 stack.push(head.val);
                 head = head.next;
           }
         
         int[] num = new int[stack.size()];
         
         for(int i = 0 ; i< num.length ;i++){
         
           num[i] = stack.pop();
         
         
         }
         
         return num;
        
        } 
   
   }
```



##### 10.9  替换空格

https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/ti-huan-kong-ge-shuang-zhi-zhen-fa-by-ja-z8rz/

```
   public class Solution{
   
       public String replaceSpace(String str){
       
                 if( str == null){
                 
                    return null;
                 }
                 
                 StringBulider sb = new StringBuilder();
                 
                 for(int i = 0 ; i< str.length(); i++){
                 
                      if(String.valueOf(str.charAt(i)).equals("")){
                      
                         sb.append("%20");
                         
                      }else{
                      
                      
                         sb.append(str.charAt(i))
                      }
                      
                 
                 }
                 
                 return sb.toString();
       
       }
   
   
   }
```

```
class Solution {
    public String replaceSpace(String s) {
        StringBuilder res = new StringBuilder();
        for(Character c : s.toCharArray())
        {
            if(c == ' ') res.append("%20");
            else res.append(c);
        }
        return res.toString();
    }
}


```





##### 10.10  二分查找算法

 时间复杂度 **logn**

```
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        int low = 0;
        int high = nums.length-1;
        int mid = 0;
        while(low <= high){
            mid = low+ (high- low) / 2;
            if(nums[mid] == target){
                while(mid != 0 &&(nums[mid-1] == nums[mid])){
                    mid--;
                }
                return mid;
            }
            else if(nums[mid] > target){
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        return -1;
    }
}
```

递归

```
   public class Solution{
   
       public int binSearch( int[]nums ,int target){
           int start = 0
           int end = nums.length-1;
              int mid = (start + end )/2
              
              if(nums[mid] == target){
              
                  return mid;
              }
              
              if(nums[mid] > target){
              
              
              }
       
       
       }
   
   
   }
```



##### 10.11 合并两个排序的链表

递归

```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        
        if(list1 == null){
            
            return list2;
        }
        
        if(list2 == null){
            
            return list1;
        }
        
        if(list1.val< list2.val){
            
            list1.next = Merge(list1.next,list2);
            return list1;
            
            
        }else{
            
            list2.next = Merge(list1,list2.next);
            return list2;
        }
        
    }
}
```

判断l1和l2当前节点的值大小，小者则放入res链表中，并进行遍历；若有其中一个为空，则将非空的剩余全部节点加到res后边即可

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode res = new ListNode(0);
        ListNode temp = res;
        while (l1 != null && l2 != null){
            if (l1.val < l2.val){
                res.next = l1;
                l1 = l1.next;
            } else {
                res.next = l2;
                l2 = l2.next;
            }
            res = res.next;
        }
        if (l2 == null){
            res.next = l1;
        } else {
            res.next = l2;
        }
        return temp.next;
    }
}

作者：drrico
链接：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/solution/jian-zhi-offer-25-he-bing-liang-ge-pai-x-lr72/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.12 跳台阶

动态规划

```
   public class Solution{
   
       public int jumpFloor(int target){
       
       
            if(target == 1 ){
            
                return 1;
            }
            
            if(target == 2 ){
            
                return 2;
            }
            
            
            int a= 1;
            int b= 2;
            int temp = 0;
            
            for( int i = 3 ;i<= target ;i++){
            
               temp = a;
               a = b;
               b = temp + b;
            
            
            }
            
            
            return b;
       
       }
   
   
   }
```



##### 10.13 设计LRU

https://blog.csdn.net/weixin_43935927/article/details/108944786

https://blog.csdn.net/LazyCancerPatiens/article/details/106453953?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242

```
LRU(Least Recently Used)，即最近最少使用算法。常用于实现一个简单的缓存功能，就是把很久未使用的直接移除掉，只保留最近使用的。

LRU主要需要实现两个功能

添加缓存(涉及到删除缓存)
获取缓存

实现原理
一个单链表就能实现简单的LRU算法：但是链表的查找时间复杂度比较高了，是O(n)。

一个散列表+双链表实现一个O(1)复杂度的LRU算法：用散列表就可以直接定位某个缓存，时间复杂度O(1)，但是散列表插入缓存之后，就没有了顺序，所以才需要一个链表来维护这个缓存的顺序，超过缓存最大容量之后需要删除未使用的缓存。而如果单链表删除某个缓存的话，又需要先遍历这个元素（时间复杂度O(n)）才行。所以这里用双链表就可以在O(1)时间复杂度内删除这个缓存了。


package com.arithmetic.code;

import java.util.HashMap;
import java.util.Map;

public class LRUCache {

    private int cacheSize = 10; // map 长度
    private Map<String,Node> map = new HashMap<>();
    private Node head; // 头部节点
    private Node tail; // 尾部节点

    public void LRUCache(int cacheSize) {
        this.cacheSize = cacheSize;
    }

    class Node{
        String key;
        String value;
        Node pre; // 当前节点的上级引用
        Node next; // 当前节点的下级引用
        
        public Node(String key,String value){
            this.key = key;
            this.value = value;
        }
    }

    /**
     * 向缓存中添加值，head为最不常用值，tail为最新值
     * 链表头部为最不常用值，最新访问或者添加的元素置于链表尾部
     */
    public void  addCache(String key,String value){
        if(map.containsKey(key)){
            // 判断Node所在位置
            Node node = map.get(key);
            if(node.next != null){ // 说明node肯定不是在链表结尾
                if(node.pre == null){ // node位于头部
                    head = node.next;
                    // 注意：新的head节点需要将pre置为null，不可省略，否则新的头部节点会存在之前的上级引用
                    head.pre = null;
                } else { // node位于链表中间
                    node.pre.next = node.next;
                    node.next.pre = node.pre;
                }
                //此时将node 放在结尾
                tail.next = node;
                node.pre = tail;
                node.next = null;
                tail = node;
            }
        } else { // map中不存在该元素
            Node node = new Node(key,value);
            if(map.size() == cacheSize){ // map已到最大存储范围
                // 将头部节点删除，然后再尾部添加最新元素
                Node temp = head;
                head = head.next;
                // 新的head节点需要将pre置为null
                head.pre = null;
                map.remove(temp.key);
                //此时将node 放在尾部
                tail.next = node;
                node.pre = tail;
                node.next = null;
                tail = node;
            } else {
                if(map.size() == 0){
                    head = node;
                    tail = node;
                } else {
                    tail.next = node;
                    node.pre = tail;
                    // 新的head节点需要将pre置为null
                    node.next = null;
                    tail = node;
                }
            }
            map.put(key,node);
        }
    }

	// 从当前缓存中获取值
    public String getCache(String key){
        if(map.containsKey(key)){ // 现有元素包含key
            Node node = map.get(key);
            if(node.next != null){
                if(node.pre == null){ //  位于头部
                    head = node.next;
                    // 新的head节点需要将pre置为null
                    head.pre = null;
                } else {
                    node.pre.next = node.next;
                    node.next.pre = node.pre;
                }
                node.pre = tail;
                tail.next = node;
                node.next = null;
                tail = node;
            }
            return node.value;
        } else {
            return null;
        }
    }

	// 进行测试
    public static void main(String[] args) {
        LRUCache cache = new LRUCache();
        cache.addCache("key0", "value0");
        cache.addCache("key1", "value1");
        cache.addCache("key2", "value2");
        cache.addCache("key3", "value3");
        cache.addCache("key4", "value4");
        cache.addCache("key5", "value5");
        cache.addCache("key6", "value6");
        cache.addCache("key7", "value7");
        cache.addCache("key8", "value8");
        cache.addCache("key9", "value9");
        //从此处开始map已满，新添加的元素会将头部删除，自身放于链表末尾
        cache.addCache("key10", "value10");
        cache.addCache("key11", "value11");
        cache.addCache("key12", "value12");
        // debug 程序可知添加此node后 head 为key4，tail 为key13
        cache.addCache("key13", "value13");
        // debug 程序可知map中head 为key5，tail 为key4（即将自身从头部移动到尾部）
        cache.getCache("key4");
    }
}



```



```
import java.util.*;


public class Solution {
    /**
     * lru design
     * @param operators int整型二维数组 the ops
     * @param k int整型 the k
     * @return int整型一维数组
     */
    public class Node{
        private int val;
        private int key;
        private Node pre =null;
        private Node next =null;
        private Node(int key,int val){
            this.val=val;
            this.key=key;
        }
    }

    private HashMap<Integer,Node> map = new HashMap();
    private Node head = new Node(-1,-1);  //头节点
    private Node tail = new Node(-1,-1);  //尾节点
    private int k=0;

    public int[] LRU (int[][] operators, int k) {
        // write code here
        this.k = k;
        head.next = tail;
        tail.pre = head;

        int len = (int)Arrays.stream(operators).filter(x->x[0]==2).count();  //获取数组中开头为2（get操作）的元素个数        
        int res[] = new int[len];

        for(int i=0,j=0;i<operators.length;i++){
            if(operators[i][0] == 1){   //获取数组中开头为1（set操作）的元素个数
                set(operators[i][1],operators[i][2]);  //set(key,val)
            }else{   //获取数组中开头为2（get操作）的元素个数
                res[j++] = get(operators[i][1]);  //get(key)
            }
        }
        return res;
    }

    public void set(int key,int val){
        //判断是否存在key 
        Node node = null;
        if(map.containsKey(key)){   //如果已经存在key，将val更新，并删除这个节点，再将node插入到表头
            node = map.get(key);
            node.val = val;
            //删除该结点
            node.next.pre = node.pre;
            node.pre.next = node.next;
            //将node节点提到第一个
            moveToFirst(node);
        }else{  //如果不存在key，先判断是否超出空间，如果超出先在链表和map删除最后一个节点，再将节点插入到表头，并将对应的映射添加到map中
            if(map.size()==k){
                //在map中删除映射到最后一个节点的key
                int keyremove =tail.pre.key;
                map.remove(keyremove);
                //在链表中删除最后一个节点
                tail.pre.pre.next = tail;
                tail.pre = tail.pre.pre;
            }
            node = new Node(key,val);
            //在map中添加对新节点的映射
            map.put(key,node);
            //将节点插入到表头
            moveToFirst(node);

        }
    }

    public int get(int key){
        // 如果不存在key 则返回-1
        // 如果存在key，先将该key的结点删除，然后再将此节点插入到链表的表头
        if(!map.containsKey(key)){
            return -1;
        }else{
            Node node = map.get(key);
            //删除该结点
            node.next.pre = node.pre;
            node.pre.next = node.next;
            //插入到表头
            moveToFirst(node);
            return node.val;
        }
    }
    //将节点插入到表头
    public void moveToFirst(Node node){
            head.next.pre =node;
            node.next =head.next;
            node.pre =head;
            head.next=node;
    }
}
```



##### 10.14 最小K个数

平均时间复杂的 nlogn, 最坏 n2，最好nlogn

https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/

```
   public class Solution{
   
        public List<Intteger> quickSort(int[] put, int k){
        
                ArrayList<Integer> res = new ArrayList<Integer>(k);
                if(k > put.length || k = 0){
                
                     return res;
                }
                
                quickSort11( put,k,0,put.length -1);
                
                return res;
        }
        
        public List<Integer> quickSort11(int[] put,int k ,int left, int right){
        
                 int start = left ;
                 int end = right;
                 
                 while(left < right){
                 
                    while(left < right && put[right] > put[start]){
                    
                      right--;
                    }
                    
                    while(left < right && put[left] < put[start]){
                    
                      left++;
                    }
                    
                    swap(put,left,right);
                 }
                 
                 swap(put ,left,start);
                 
                 if(left > K){ 
                 
                 quickSort11(put,res,k,start,left-1)
                 
                 }else if(left < K){
                 
                 quickSort11(put,res,k,left+1,end)
                 
                 }else{
                 
                    if(i = 0;i<k;m++){
                    
                       res.add(input[m]);
                    }
                 }
                 
                 
        
        }
        
       private void swap(int[] arr, int i, int j) {
        if (i == j)
            return;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
   
   }
```



```
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        quickSort(arr, 0, arr.length - 1);
        return Arrays.copyOf(arr, k);
    }
    private void quickSort(int[] arr, int l, int r) {
        // 子数组长度为 1 时终止递归
        if (l >= r) return;
        // 哨兵划分操作（以 arr[l] 作为基准数）
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr, i, j);
        }
        swap(arr, i, l);
        // 递归左（右）子数组执行哨兵划分
        quickSort(arr, l, i - 1);
        quickSort(arr, i + 1, r);
    }
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k >= arr.length) return arr;
        return quickSort(arr, k, 0, arr.length - 1);
    }
    private int[] quickSort(int[] arr, int k, int l, int r) {
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr, i, j);
        }
        swap(arr, i, l);
        if (i > k) return quickSort(arr, k, l, i - 1);
        if (i < k) return quickSort(arr, k, i + 1, r);
        return Arrays.copyOf(arr, k);
    }
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.15 丑数



```
基本思路
根据丑数的定义，我们有如下结论：

 是最小的丑数。
对于任意一个丑数 ，其与任意的质因数（、、）相乘，结果（、、）仍为丑数。
优先队列（小根堆）解法
有了基本的分析思路，一个简单的解法是使用优先队列：

起始先将最小丑数  放入队列
每次从队列取出最小值 ，然后将  所对应的丑数 、 和  进行入队。
对步骤 2 循环多次，第  次出队的值即是答案。
为了防止同一丑数多次进队，我们需要使用数据结构  来记录入过队列的丑数。


import java.util.*;
public class Solution {
    int[] nums = new int[]{2,3,5};
    public int GetUglyNumber_Solution(int n) {
        if (n == 0) return 0;
        Set<Long> set = new HashSet<>();
        Queue<Long> pq = new PriorityQueue<>();
        set.add(1L);
        pq.add(1L);
        for (int i = 1; i <= n; i++) {
            long x = pq.poll();
            if (i == n) return (int)x;
            for (int num : nums) {
                long t = num * x;
                if (!set.contains(t)) {
                    set.add(t);
                    pq.add(t);
                }
            }
        }
        return -1;
    }
}
```



```
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if(index<=0) return 0;
        int p2=0,p3=0,p5=0;
        int[] result=new int[index];
        result[0]=1;
        for(int i=1;i<index;i++){
            result[i]=Math.min(result[p2]*2,Math.min(result[p3]*3,result[p5]*5));
            if(result[i]==result[p2]*2) p2++;//之前的每一个丑数都需要进行乘以2或者3或者5的操作。p2,p3,p5用来记录当前那个丑数之前已经进行完乘2的操作了
            if(result[i]==result[p3]*3) p3++;
            if(result[i]==result[p5]*5) p5++;
        }
        return result[index-1];
    }
}
```



##### 10.16  最大公约数



```

我们用辗转相除法（又称欧几里得算法）来计算两个数的最大公约数 (Greatest Common Divisor)所以下文用gcd(a,b)表示a和b的最大公约数。

先举一个例子：
假如需要求 434 和 652 的最大公约数,用欧几里得算法，是这样进行的：
434 / 652 = 0 (余 434)
652 / 434 = 1(余218)
434 / 218 = 216(余2)
218 / 2 = 109 (余0)
以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 434 和 652 的最大公约数 2。

算法的核心其实是 ： （即： 和  的最大公约数等于  和  的最大公约数。这个性质在本文最后会给出证明）
然后我们考虑，对于两个数  ， 如果的话,那这两个数的最大公约数是 
这样的话代码我们就可以直接写出来了。



import java.util.*;
public class Solution {
    public int gcd (int a, int b) {
        if(a%b==0){return b;}
        else{return gcd(b,a%b);}
    }
}
```



##### 10.17 大数相加

https://blog.csdn.net/yang10560/article/details/86527911

https://cloud.tencent.com/developer/article/1846675

##### 10.18 旋转数组



```

```



##### 10.19 最长回文字串



```

```



##### 10.20 最大堆,求最小K个数

https://www.cnblogs.com/chengxiao/p/6129630.html

https://blog.csdn.net/mrliar17/article/details/86716212

我们要保证堆的大小不能超过K，然后遍历数组，因为是最大堆，也就是堆顶元素是堆中最大的，如果遍历的元素小于堆顶元素，就把堆顶元素给移除，然后再把当前遍历的元素加入到堆中，最后在把堆中元素转化为数组即可

```
    public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
        ArrayList<Integer> res = new ArrayList<>(k);
        //根据题意要求，如果K>数组的长度，返回一个空的数组
        if (k > input.length || k == 0)
            return res;
        //创建最大堆
        PriorityQueue<Integer> queue = new PriorityQueue<>((num1, num2) -> num2 - num1);
        //先在堆中放数组的前k个元素
        for (int i = 0; i < k; ++i) {
            queue.offer(input[i]);
        }
        //因为是最大堆，也就是堆顶的元素是堆中最大的，遍历数组后面元素的时候，
        //如果当前元素比堆顶元素大，就把堆顶元素给移除，然后再把当前元素放到堆中，
        for (int i = k; i < input.length; ++i) {
            if (queue.peek() > input[i]) {
                queue.poll();
                queue.offer(input[i]);
            }
        }
        //最后再把堆中元素转化为数组
        for (int i = 0; i < k; ++i) {
            res.add(queue.poll());
        }
        return res;
    }
```



##### 10.21 买卖股票的最好时机

https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=190&&tqId=35181&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking

这是一个典型的动态规划问题。

- **最优子结构**

  在自下而上的递推过程中，我们求得的每个子问题一定是**全局最优解**，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。

- **重复子问题**

  递归地寻找子问题的最优解时，子问题会重叠地出现在子问题里，会有很多重复的计算，动态规划可以保证每个重叠的子问题只会被求解一次。

动态规划解题步骤：

1. 定义子问题
2. 写出子问题的递推关系
3. 确定DP数组的计算顺序

本题中的具体表现为：

```
dp[i]  i天卖出的最大收益``
buy 买进日期``
sell 卖出日期``
dp[i] = 今天卖出日期-最小买进日期;
dp[``0``] = ``0``;
```



```
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int res = 0;
        int len = prices.length;
        int dp =  prices[0];
        int buy = prices[0];
        int sell = prices[0];
        for(int i = 1; i < len; i++){
            sell = prices[i];
            if(sell < buy) buy = sell;
            dp = sell - buy;
            res = Math.max(dp, res);
        }

        return res;
    }
}
```



##### 10.22 判断是否回文

https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2?tpId=190&&tqId=36606&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking

题中说了只有小写字母，最简单的就是使用双指针，一个指向前，一个指向后，两个指针同时往中间走，如果两个指针指向的字符不一样就返回false



```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
       public boolean judge(String str) {
        if (str.length() == 0)
            return true;
        //两个指针，一个从左边开始，一个从右边开始，每次两个
        //指针都同时往中间挪，只要两个指针指向的字符不一样就返回false
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left++) != str.charAt(right--))
                return false;
        }
        return true;
    }
}
```



##### 10.23 二叉树的最大深度



```
   public class Solution{
   
         public int MaxDepth(TreeNode root){
         
         
                int leftDepth = MaxDepth(rooot.left);
                int rightDepth = MaxDepyyh(root.right);
                
                return Matn.max(leftDepth , rightDepth) +1;
         
         
         }
   
   }
```



##### 10.24  判断该二叉树是否是平衡二叉树



```
public class Solution {
    boolean flag = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root==null) return true;
        pre(root);
        return flag;
    }
    public int pre(TreeNode root){
        if(root==null) return 0;
        int left = pre(root.left);
        int right = pre(root.right);
        if(Math.abs(left-right)>1) flag = false;
        return Math.max(left,right)+1;
    }
}
```



##### 10.25 合并K个已排序的链表



```
public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        int size = lists.size();
        if(size == 0){
            return null;
        }
        if(size == 1){
            return lists.get(0);
        }
        ListNode node = lists.get(0);
        for(int i = 1; i < size; i++){
            //参数为 node ，list.size()>2,会多次合并，不可用lists.get(0)
             node = mergeLists(node,lists.get(i));
        }
        return node;
        
    }
    
    public ListNode mergeLists(ListNode node1,ListNode node2){
        ListNode node = new ListNode(-1);
        //操作temp 会有些数据丢失，关联node 同时用node 保存链表
        ListNode temp = node;
        while(node1 != null && node2 != null){
            if(node1.val < node2.val){
                temp.next = node1;
                node1 = node1.next;
            }else{
                temp.next = node2;
                node2 = node2.next;
            }
            //为了后面的连接temp.next = node1 != null ? node1 : node2;
            temp = temp.next;
        }
        //temp 连接多余的node
        temp.next = node1 != null ? node1 : node2;
        return node.next;
    }
}
```



##### 10.26 删除链表的重复元素

set**去重**

```
    public ListNode removeDuplicateNodes(ListNode head) {
        Set<Integer> set = new HashSet<>();
        ListNode cur = head;
        while (cur != null && cur.next != null) {
            set.add(cur.val);
            if (set.contains(cur.next.val))
                cur.next = cur.next.next;
            else
                cur = cur.next;
        }
        return head;
    }

作者：sdwwld
链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/solution/javade-4chong-xie-fa-bao-gua-di-gui-wei-yun-suan-b/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

**双指针**

```

```



##### 10.27 多线程打印ABC



###### 使用ReentrantLock

```
public class Solution{

         private static ReentrantLock lock = new Reentrantlock();
         private static int state = 0;
         
         static class ThreadA extends Thread{
         
                @Override
                public void run(){
                
                 for(int i =0 ;i< 10 ;i++){
                 
                   try{
                         lock.lock();
                        if(state % 3 = 0){
                           system.out.print("A");
                           state++;
                           i++;
                        }
                   
                   }catch{
                     e.printTrace();
                   }finally{
                      lock.unlock();
                   
                   }
                 
                 }
                
                
                }
                
         
         }
         
         static class ThreadB extends Thread{
         
               @Override
               public void run(){
               
                  for(int i=0;i<10;i++){
                  
                       try{
                           lock.lock();
                         if(state % 3 = 1){
                         
                      
                          System.out.print("C");
                          state++;
                          i++
                           
                         
                         }
                       
                       }finally{
                       
                         lock.unlock();
                       }
                  
                  }
               
               }
         
         }
         
         static class ThreadC extend Thread{
         
                 @Override
                 public void run(){
                 
                      for(int i = 0 ; i<10 ; i++){
                      
                           try{
                               lock.lock();
                               if( state % 3 == 3 ){
                               
                                 state++;
                                 i++;
                               }
                                 
                           
                           }finally{
                           
                             lock.unlock();
                           }
                      }
                 
                 }
                 
         
         }


}
```



##### 10.28 二叉搜索树的第k大节点

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/

```
public class Solution {

    private static List<Integer> arr=new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        //中序遍历,正序赋值数组
        inOrder(root);
        //寻找第k大的数，输出
        return arr.get(arr.size()-k);
    }
    //中序遍历
    private static void inOrder(TreeNode root){
        if(root==null)
            return;
        inOrder(root.left);
        arr.add(root.val);
        inOrder(root.right);

    }
}

```



##### 10.29 合并二叉树



```

```



##### 10.30  [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)



```

```



##### 10.31 [最小面积矩形](https://leetcode-cn.com/problems/minimum-area-rectangle/)

##### 10.32 顺时针打印矩阵

https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/jian-zhi-offer-29-shun-shi-zhen-da-yin-j-7049/

```
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return new int[0];
        int n = matrix.length, m = matrix[0].length;
        int top = 0, bottom = n - 1;
        int left = 0, right = m - 1;
        int[] res = new int[n * m];
        int index = 0;
        while(true){
            // 左 -> 右
            for(int i = left; i <= right; i++){
                res[index++] = matrix[top][i];
            }
            top++;
            if(top > bottom) break;

            // 上 -> 下
            for(int i = top; i <= bottom; i++){
                res[index++] = matrix[i][right];
            }
            right--;
            if(left > right) break;

            // 右 -> 左
            for(int i = right; i >= left; i--){
                res[index++] = matrix[bottom][i];
            }
            bottom--;
            if(top > bottom) break;

            // 下 -> 上
            for(int i = bottom; i >= top; i--){
                res[index++] = matrix[i][left];
            }
            left++;
            if(left > right) break;
        }
        return res;
    }
}

作者：edelweisskoko
链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/jian-zhi-offer-29-shun-shi-zhen-da-yin-j-7049/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.33 旋转矩阵

```
先上下交换，在对角线交换
```

![leet0048.png](https://pic.leetcode-cn.com/1615651665-WFwYuH-leet0048.png)

https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/shu-ju-jie-gou-he-suan-fa-liang-chong-sh-vkrf/

```
    public void rotate(int[][] matrix) {
        int length = matrix.length;
        //先上下交换
        for (int i = 0; i < length / 2; i++) {
            int temp[] = matrix[i];
            matrix[i] = matrix[length - i - 1];
            matrix[length - i - 1] = temp;
        }
        //在按照对角线交换
        for (int i = 0; i < length; ++i) {
            for (int j = i + 1; j < length; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }

```

##### 10.34 [二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/

```
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int i = matrix.length - 1, j = 0;
        while(i >= 0 && j < matrix[0].length)
        {
            if(matrix[i][j] > target) i--;
            else if(matrix[i][j] < target) j++;
            else return true;
        }
        return false;
    }
}

```

##### 10.35 [ 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/

##### 10.36 链表指定区间反转

https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=188&&tqId=38555&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummy = new ListNode(-1);  // 哑巴节点，指向链表的头部
        dummy.next = head;
        ListNode pre = dummy;  // pre 指向要翻转子链表的前驱节点
        for (int i = 1; i < m; ++i) {
            pre = pre.next;
        }
        head = pre.next;  // head指向翻转子链表的首部
        ListNode next;
        for (int i = m; i < n; ++i) {
            next = head.next;
            // head节点连接next节点之后链表部分，也就是向后移动一位
            head.next = next.next;
            // next节点移动到需要反转链表部分的首部
            next.next = pre.next;
            // pre继续为需要反转头节点的前驱节点
            pre.next = next;
        }
        return dummy.next;
    }
}
```



##### 10.37 连续子数组的最大和

动态规划

https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=117&&tqId=37797&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking

```
典型的动态规划。dp[n]代表以当前元素为截止点的连续子序列的最大和，如果dp[n-1]>0，dp[n]=dp[n]+dp[n-1]，因为当前数字加上一个正数一定会变大；如果dp[n-1]<0，dp[n]不变，因为当前数字加上一个负数一定会变小。使用一个变量max记录最大的dp值返回即可。

public int FindGreatestSumOfSubArray(int[] array) {
    int max = array[0];
    for (int i = 1; i < array.length; i++) {
        array[i] += array[i - 1] > 0 ? array[i - 1] : 0;
        max = Math.max(max, array[i]);
    }
    return max;
}
```



##### 10.38 最长无重复子数组

https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=117&&tqId=37816&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking

```
我们还可以用一个队列，把元素不停的加入到队列中，如果有相同的元素，就把队首的元素移除，这样我们就可以保证队列中永远都没有重复的元素

    public int maxLength(int[] arr) {
        //用链表实现队列，队列是先进先出的
        Queue<Integer> queue = new LinkedList<>();
        int res = 0;
        for (int c : arr) {
            while (queue.contains(c)) {
                //如果有重复的，队头出队
                queue.poll();
            }
            //添加到队尾
            queue.add(c);
            res = Math.max(res, queue.size());
        }
        return res;
    }
```



##### 10.39 合并两个有序数组



```
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int i=m-1, j=n-1, k=m+n-1;
        while (i>=0 && j>=0) {
            if (A[i] > B[j]) {
                A[k--] = A[i--];
            } else {
                A[k--] = B[j--];
            }
        }
        while (j>=0) {
            A[k--] = B[j--];
        }
    }
}
```

##### 10.40 重建二叉树

##### 10.41 斐波那契数列

https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=117

```
public class Solution {
    public int Fibonacci(int n) {
        if(n <= 2){
            return 1;
        }
        int sum = 0;
        int two = 0;
        int one = 1;
        for(int i=2;i<=n;i++){
            sum = two + one;
            two = one;
            one = sum;
        }
        return sum;
    }
}
```



##### 10.42 链表相加

https://leetcode-cn.com/problems/sum-lists-lcci/solution/javajian-ji-dai-ma-yi-ge-xun-huan-by-bug-hced/

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int x = 0;  // 进位
        ListNode dummy = new ListNode(0);   // 哑节点
        ListNode node = dummy;
        
        while(l1 != null || l2 != null || x != 0) {
            int sum = x;    // 当前位的和
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }
            node.next = new ListNode(sum % 10);
            x = sum / 10;
            node = node.next;
        }
        return dummy.next;
    }
}

作者：buglesxu
链接：https://leetcode-cn.com/problems/sum-lists-lcci/solution/javajian-ji-dai-ma-yi-ge-xun-huan-by-bug-hced/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
   /**
     * 先相加再反转
     *
     * @param l1
     * @param l2
     * @return
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
         ListNode dummy = new ListNode(-1);
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode curr = dummy;
        int carry = 0;
        while (p1 != null || p2 != null) {
            int sum = 0;

            int x = p1 == null ? 0 : p1.val;
            int y = p2 == null ? 0 : p2.val;
            sum = x + y + carry;

            // p1 和 p2 往后移动一个单位
            if (p1 != null) {
                p1 = p1.next;
            }
            if (p2 != null) {
                p2 = p2.next;
            }
            
            // 计算进位
            carry = sum / 10;
            // 用10 对 sum 进行取余操作，并用这个余数 创建新节点
            sum = sum % 10;
            curr.next = new ListNode(sum);
            curr = curr.next;

        }
        
        if(carry>0){
            curr.next = new ListNode(carry);
        }
        return dummy.next;

}
}

作者：ai-zhe-teng-de-xiao-huo-er
链接：https://leetcode-cn.com/problems/sum-lists-lcci/solution/fang-zhao-letcode-2-liang-shu-zhi-he-by-w2ayu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=202&&tqId=38844&rp=1&ru=/activity/oj&qru=/ta/code-written-high/question-ranking

```
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        ListNode newNode=new ListNode(-1);
        ListNode temp=newNode;
        ListNode new1=reverse_(head1);
        ListNode new2=reverse_(head2);
        int x=0;
        while(new1!=null || new2!=null || x!=0){
            int sum=x;
            if(new1!=null){
                sum+=new1.val;
                new1=new1.next;
            }
            if(new2!=null){
                sum+=new2.val;
                new2=new2.next;
            }
            temp.next=new ListNode(sum%10);
            x=sum/10;
            temp=temp.next;
        }
        return reverse_(newNode.next);
    }
    public ListNode reverse_(ListNode head){
        ListNode slower=null;
        ListNode faster=head;
        ListNode temp=faster;
        while(faster!=null){
            temp=faster.next;
            faster.next=slower;
            slower=faster;
            faster=temp;
        }
        return slower;
    }
}
```



##### 10.43 一个字符串，一个子字符串，判断子字符串在字符串中出现的次数，不要求连续，但有先后顺序  s=rabbbit  t=rabbit，出现的次数为3

##### 10.44 反转双向链表

```
   public class Solution{
   
        public DoubleNode reverList( DoubleNode head){
        
               DoubleNode next = null;
               DOubleNode pre = null;
               
               while( head != null){
               
                    next = head.next;
                    head.next = pre;
                    head.last = next;
                    pre = head;
                    head = next;
               
               }
               
               return pre;
        
        }
   
   }
```



##### 10.45 单链表排序

快排

```
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    public void swap(ListNode a,ListNode b){
        int t=a.val;
        a.val=b.val;
        b.val=t;
    }
    public void quickSort(ListNode head,ListNode end){
        if(head==end||head.next==end){
            return;
        }
        ListNode slow=head,fast=head.next;
        int pivot=head.val;
        while(fast!=end){
            if(fast.val<=pivot){
                slow=slow.next;
                swap(slow,fast);
            }
            fast=fast.next;
        }
        swap(head,slow);
        quickSort(head,slow);
        quickSort(slow.next,end);
    }
    public ListNode sortInList (ListNode head) {
        // write code here
        quickSort(head,null);
        return head;
    }
}

```



##### 10.46 **删除链表的倒数第n个节点**

https://www.nowcoder.com/practice/f95dcdafbde44b22a6d741baf71653f6?tpId=117&&tqId=37750&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking

```
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param n int整型 
     * @return ListNode类
     */
  public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast = head;
    ListNode slow = head;
    //fast移n步，
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }
    //如果fast为空，表示删除的是头结点
    if (fast == null)
        return head.next;

    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    //这里最终slow不是倒数第n个节点，他是倒数第n+1个节点，
    //他的下一个结点是倒数第n个节点,所以删除的是他的下一个结点
    slow.next = slow.next.next;
    return head;
}
}
```



##### 10.47 队列实现栈

```
   public  class  Solution{
         Queue<Integer> A = new Queue<Integer>();
         Queue<Integer> B = new Queue<Integer>();
         
         public 
        
   
   }
```



##### 10.48  手撕阻塞队列

```
public class Solution{



}
```



##### 10.49 手撕线程死锁



https://blog.csdn.net/qq_38215042/article/details/87859890

```
public class Solution{

   Object t1 = new Object();
   Object t2 = new Object();
   
   new Thread (new Runnable(){
       
       @Override
       public void run(){
       
         String name = Thread,currentThread().getName();
         synchronized(t1){
          System.out.print("当前线程" + name);
          try{
          
             Thread.sleep(100);
          }catch( InterruptedException e)
           
           e.printStackTrace();
         }
         
         synchronized(t2){
         
            System.out.print("ddddd");
         }
         
       
       }
   
   },"线程A").start();
   
   
   new Thread(new Runnable(){
       @Override
       public void run(){
       
          String name = Thread.currentThread().getName();
          synchronized(t2){
          
            System,out.print("当前线程" + name);
            
            try{
            
              Thread.sleep(100);
            
            }catch( InterruptedException e){
            
              e.printStackTrace();
            }
            
            synchronized(t1){
            
               System.out.print("dddddd");
            }
            
          }
       
       }
   
   
   },"线程B").start();
   
}
```



##### 10.50 ThreadLocal

```
public class LoginInfoThreadLocal{

   private static final ThreadLocal<LoginInfo> local = new ThreadLocal<LoginInfo>();
   
   
   public static void set(LoginInfo bean){
   
      local.set(bean);
   }
   
   public static LoginInfo get(){
   
      local.get();
   }

}
```

##### 10.51 把数组排成最小的数

##### 10.52 给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。 

https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-iwq7d/



解题思路
       2
      / \
     1   4
        / \
       3   6
若 pp 是值为 66 的节点，qq 是值为 11 的节点，则它们的最近公共祖先就是值为 22 的节点（rootroot 节点）；若 pp 是值为 66 的节点，qq 是值为 33 的节点，则它们的最近公共祖先就是值为 44 的节点。

一个节点的祖先，除了它的父节点、父节点的父节点等外，它本身也是自己的祖先，比如值为 66 的节点，它的祖先为：值为 2、4、62、4、6 的节点。



```
class Solution {

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        if (root == null) return null;
        if (root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left != null && right != null) return root;

        if (left == null && right == null) return null;

        return left == null ? right : left;
    }
}

作者：Booooo_
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-iwq7d/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.53 **找到搜索二叉树中两个错误的节点**

```
棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请按升序输出这两个错误节点的值。(每个节点的值各不相同)

public static int[] findError (TreeNode root) {
        // write code here
        return process(root);
    }

    public static int[] process(TreeNode root){
        int[] ret = new int[2];
        if(root == null )return ret;
        Stack<TreeNode> stack = new Stack<>();
        int preValue = root.val;
        while(!stack.isEmpty() || root != null){
            while(root!= null){
                stack.add(root);
                root = root.left;
            }
            root = stack.pop();

            // process
            if(preValue > root.val){
                if(ret[1] == 0){
                    ret[0] = root.val;
                    ret[1] = preValue;
                }else {
                    if(preValue > ret[1]) ret[1] = preValue;
                    if(root.val < ret[0])ret[0] = root.val;
                }
            }
            preValue = root.val;
            root = root.right;
        }
        return ret;
    }

```



##### 10.54 给定无序数组arr，返回其中最长的连续序列的长度(要求值连续，位置可以不连续,例如 3,4,5,6为连续的自然数）

```
import java.util.*;

public class Solution {
    /**
     * max increasing subsequence
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int MLS (int[] arr) {
        if(arr == null || arr.length == 0){
            return 0;
        }

        int len = arr.length;
        Arrays.sort(arr);
        int count = 1;
        int result = 1;
        for(int i=0;i<len-1;i++){
            if(arr[i+1] - arr[i] == 1){
                count++;
            }else if(arr[i+1] - arr[i] == 0){
                continue;
            }else{
                count = 1;
            }

            result = Math.max(count, result);
        }

        return result;
    }
}
```



##### 10.55 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

```
import java.util.*;
public class Solution {
    public int[] FindNumsAppearOnce (int[] array) {
        ArrayList list = new ArrayList();
        for (int i = 0; i < array.length; i++) {
            if (list.contains(array[i])) {
                list.remove((Object) array[i]);
            } else {
                list.add(array[i]);
            }
        }
        return new int[]{list.get(0), list.get(1)};
    }
}
```



##### 10.56 给定一个单链表，请设定一个函数，讲链表的奇数位节点和偶数位节点分别放在一起，重排后输出。

```

class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head==null){
            return head;
        }
        ListNode evenhead=head.next;
        ListNode odd=head; //奇数
        ListNode even=evenhead; // 偶数
        //可以选择用奇数或者偶数点来表示退出条件，奇数.next=偶数
        // while(even!=null&&even.next!=null){
        while(odd.next!=null&&odd.next.next!=null){
            //奇数点的下一个点是偶数点的下一个节点
            odd.next=even.next;
            odd=odd.next;
            //偶数点的下一个点是更新后的奇数点的下一个节点
            even.next=odd.next;
            even=even.next;
        }
       odd.next=evenhead;
       return head;
    }
}



```



```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        //0,1,2个节点，直接返回即可
        if(head == null || head.next == null || head.next.next == null){
            return head;
        }
        ListNode evenHead = head.next;
        ListNode odd = head;
        ListNode even = evenHead;
        //奇数节点和偶数节点分离开
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        //连接上
        odd.next = evenHead;
        return head;
    }
}

作者：LeetcodeFrom20210207
链接：https://leetcode-cn.com/problems/odd-even-linked-list/solution/328-qi-ou-lian-biao-by-leetcodefrom20210-ox23/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
function oddEvenList( head ) {
    // write code here
    if(!head) return head
    let odd = head       ///扫描奇链节点
    let even = head.next  ///扫描偶链节点
    let evenHead = even    //保存偶数链的节点
    while(even&&even.next){
        odd.next = odd.next.next //指向下一个奇数节点
        even.next = even.next.next //指向下一个奇数节点
        odd = odd.next  //odd推进到下一个奇数节点
        even = even.next //even推进到下一个偶数节点
    }
    odd.next = evenHead //奇数链连上偶数链
    return head
}
```





##### 10.57 重建二叉树

https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/

```
class Solution {
    int[] preorder;
    HashMap<Integer, Integer> dic = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        for(int i = 0; i < inorder.length; i++)
            dic.put(inorder[i], i);
        return recur(0, 0, inorder.length - 1);
    }
    TreeNode recur(int root, int left, int right) {
        if(left > right) return null;                          // 递归终止
        TreeNode node = new TreeNode(preorder[root]);          // 建立根节点
        int i = dic.get(preorder[root]);                       // 划分根节点、左子树、右子树
        node.left = recur(root + 1, left, i - 1);              // 开启左子树递归
        node.right = recur(root + i - left + 1, i + 1, right); // 开启右子树递归
        return node;                                           // 回溯返回根节点
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

用栈

```
如果使用栈来解决首先要搞懂一个知识点，就是前序遍历挨着的两个值比如m和n，他们会有下面两种情况之一的关系。

1，n是m左子树节点的值。

2，n是m右子树节点的值或者是m某个祖先节点的右节点的值。

对于第一个知识点我们很容易理解，如果m的左子树不为空，那么n就是m左子树节点的值。

对于第二个问题，如果一个结点没有左子树只有右子树，那么n就是m右子树节点的值，如果一个结点既没有左子树也没有右子树，那么n就是m某个祖先节点的右节点，我们只要找到这个祖先节点就好办了



public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder.length == 0)
        return null;
    Stack<TreeNode> s = new Stack<>();
    //前序的第一个其实就是根节点
    TreeNode root = new TreeNode(preorder[0]);
    TreeNode cur = root;
    for (int i = 1, j = 0; i < preorder.length; i++) {
        //第一种情况
        if (cur.val != inorder[j]) {
            cur.left = new TreeNode(preorder[i]);
            s.push(cur);
            cur = cur.left;
        } else {
            //第二种情况
            j++;
            //找到合适的cur，然后确定他的右节点
            while (!s.empty() && s.peek().val == inorder[j]) {
                cur = s.pop();
                j++;
            }
            //给cur添加右节点
            cur = cur.right = new TreeNode(preorder[i]);
        }
    }
    return root;
}

作者：sdwwld
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/4chong-jie-fa-di-gui-zhan-dui-lie-by-sdwwld/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.58 给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

##### 10.59 n! 是指自然数 n! 的阶乘,即 : ![img](https://www.nowcoder.com/equation?tex=N!%3D1%20%5Ctimes%202%5Ctimes3%E2%80%A6(N-2)%5Ctimes(N-1)%20%5Ctimes%20N)。

特殊的, 0 的阶乘是 1 。

数据范围： ![img](https://www.nowcoder.com/equation?tex=0%20%3C%20n%20%5Cle%2010%5E%7B14%7D%20%5C)

进阶：空间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(1)%20%5C)，时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(logn)%5C)

复杂度要求：

不大于 ![img](https://www.nowcoder.com/equation?tex=O(%5Clog%20n))

```

  
  
  
  public long thenumberof0 (long n) {
        //每次对10取余，然后再/10，再取余
        if(n==0) return 1;
        //结果为0的个数只与2与5的个数有关。因为2的个数肯定要大于5的个数，所以只要关注5的个数就可以了.
        long i=5,count=0;
        while(i<=n){
            count=count+n/i;
            i=i*5;//5有1个5，因此n是5的几倍就有几个5，而n有几个25又多出一个5来
        }
       return count;
    }

}



```

##### 10.60 [两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

解题思路：
我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。

这样，当它们相遇时，所指向的结点就是第一个公共结点。

作者：z1m
链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/shuang-zhi-zhen-fa-lang-man-xiang-yu-by-ml-zimingm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A = headA, B = headB;
        while (A != B) {
            A = A != null ? A.next : headB;
            B = B != null ? B.next : headA;
        }
        return A;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/jian-zhi-offer-52-liang-ge-lian-biao-de-gcruu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
public class Solution {
    public ListNode getIntersectionNode(ListNode a, ListNode b) {
        Deque<ListNode> d1 = new ArrayDeque<>(), d2 = new ArrayDeque<>();
        while (a != null) {
            d1.add(a);
            a = a.next;
        }
        while (b != null) {
            d2.add(b);
            b = b.next;
        }
        ListNode ans = null;
        while (!d1.isEmpty() && !d2.isEmpty() && d1.peekLast() == d2.peekLast()) {
            ans = d1.pollLast();
            d2.pollLast();
        }
        return ans;
    }
}

作者：AC_OIer
链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/solution/gong-shui-san-xie-zhao-liang-tiao-lian-b-ifqw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.61 二叉树的路径和



```
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null)
        return false;
        if(root.left==null&&root.right==null){
        
        return root.val==targetSum;
        
        }
        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);
    }
}

作者：oahrats
链接：https://leetcode-cn.com/problems/path-sum/solution/112-lu-jing-zong-he-by-oahrats-5ibo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    //因为是判断是否有 所以先定义没有 遍历一遍如果有就true
    boolean isSum = false;

    public boolean hasPathSum(TreeNode root, int targetSum) {
        //首先如果root为空 返回false
        if (root == null) {
            return false;
        }
        //process传root 当前和 tergetSum
        process(root, 0, targetSum);
        return isSum;
    }

    //定义process方法无需返回值
    void process(TreeNode root, int preSum, int targetSum) {
        //判断当前是不是叶子节点 root.left\right是否都为空
        if (root.left == null && root.right == null) {
            //为空计算判断当前值是否达到
            if (preSum + root.val == targetSum) {
                isSum = true;
            }
        }
        //将值加到当前值里
        preSum += root.val;
        //不为空继续向下调左子树和右子树
        if (root.left != null) {
            process(root.left, preSum, targetSum);
        }
        if (root.right != null) {
            process(root.right, preSum, targetSum);
        }
    }
}

作者：admiring-morsezho
链接：https://leetcode-cn.com/problems/path-sum/solution/xiang-jian-dai-ma-zhu-shi-by-admiring-mo-o7zh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.62 冒泡排序

https://www.cnblogs.com/morethink/p/8419151.html#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F

```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型一维数组 待排序的数组
     * @return int整型一维数组
     */
    public int[] MySort (int[] arr) {
        // write code here
        
        for( int i = 0 ; i< arr.length-1 ;i++){
            
            for(int j = 0 ;j< arr.length-i-1;j++){
                
                if(arr[j] > arr[j+1]){
                    
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
            
            
        }
        
        return arr;
    }
}
```



##### 10.63 矩阵不同路径

https://leetcode-cn.com/problems/unique-paths/

https://juejin.cn/post/7014667922991742983



```
class Solution {
    public int uniquePaths(int m, int n) {
//        先填充左侧和上侧边界
        int[][] map=new int[m][n];
        for (int i = 0; i < m; i++) {
            map[i][0]=1;
        }
        for (int i = 0; i < n; i++) {
            map[0][i]=1;
        }
        
//        从从上到下,从左到右的顺序
        for (int i = 1; i <m ; i++) {
            for (int j = 1; j < n; j++) {
                map[i][j]=map[i-1][j]+map[i][j-1];
            }
        }
        return map[m-1][n-1];

    }
}

作者：seventeenth
链接：https://leetcode-cn.com/problems/unique-paths/solution/chao-yi-dong-si-zhang-tu-miao-dong-dong-6qhz2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
解题思路
首先了解下动态规划的思想。
动态规划用于处理有重叠子问题的问题。其基本思想：假如要解一个问题，需要先将问题分解成子问题，求出子问题的解，再根据子问题的解得出原问题的解。
动态规划算法会将计算出来的子问题的解存储起来，以便下次遇到同一个子问题的时候直接可以得到该子问题的解，减少重复计算。
动态规划的解题思路：1、状态定义；2、状态转移方程；3、初始状态；4、确定遍历顺序。
接下来分步骤讲解本题目的思路。
1、首先是状态定义。假设 dp[i][j] 是到达 (i, j) 的路径数量，dp[2][2]就是到达(2, 2)的路径数量。
2、然后是状态转移方程。根据题意，只能向右和向下运动，当前位置(i, j)只能从(i-1, j)和(i, j-1)两个方向走过来，由此可以确定状态方程为dp[i][j] = dp[i-1][j] + dp[i][j-1]。

3、初始状态。对于第一行 dp[0][j]和第一列 dp[i][0]，由于都在边界，只有一个方向可以走，所以只能为 1。
4、确定遍历顺序。dp[i][j]是从其上边和左边推导而来，所以按照从左到右，从上到下的顺序来遍历。

作者：程序员大彬
链接：https://juejin.cn/post/7014667922991742983
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


class Solution {
    public int uniquePaths(int m, int n) {
        //一维空间，其大小为 n
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for(int i = 1; i < m; ++i) {
            for(int j = 1; j < n; ++j) {
                //等式右边的 dp[j]是上一次计算后的，加上左边的dp[j-1]即为当前结果
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return dp[n - 1];
    }   
}

作者：wang_ni_ma
链接：https://leetcode-cn.com/problems/unique-paths/solution/san-chong-shi-xian-xiang-xi-tu-jie-62-bu-4jz1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.64 三个数的最大乘积



```
import java.util.*;


public class Solution {
    /**
     * 最大乘积
     * @param A int整型一维数组 
     * @return long长整型
     */
    public long solve (int[] A) {
        // write code here
        int max1 = Integer.MIN_VALUE,
            max2 = Integer.MIN_VALUE,
            max3 = Integer.MIN_VALUE;
        int min1 = Integer.MAX_VALUE,
            min2 = Integer.MAX_VALUE;
        for(int a : A){
            if(a>max1){
                max3 = max2;
                max2 = max1;
                max1 = a;//第一大
                
            }else if(a>max2){
                max3 = max2;
                max2 = a;//第二大
            }else if(a>max3){
                max3 = a;//第三大
            }
            if(a<min1){
                min2 = min1;
                min1 = a;//第二小
            }else if(a<min2){
                min2 = a ;//第一小
            }
        }
        return Math.max((long)max1*max2*max3,(long)min1*min2*max1);
    }
}
```



##### 10.65

##### 10.66

##### 10.67

##### 10.68

##### 10.69

##### 10.70

##### 10.71

##### 10.72

##### 10.73

10.74

10.75

10.76

10.77

10.78

10.79

10.80

10.81

10.82

10.83

10.84

10.85

10.86

10.87

10.88

10.89

10.90



#### 11. JVM

##### 11.1  JVM内存模型



```
程序计数器  ， 记录CPU指令，私有
java虚拟机栈，私有
本地虚拟机栈，私有
堆内存
方法区

```

##### 11.2 编译原理



```
1. 词法分析 ，token流

2. 语法分析，

3. 语义分析；

4. 字节码生成，
```

**java 如何从源代码转换成机器码执行的**



##### 11.3 类加载过程



```
1. 加载

2. 链接：
   
   验证，语法是否符合JVM规范
   准备，给静态变量赋值，int = 0
   解释, 间接引用转为直接引用
   
3. 初始化

4. 卸载
```



##### 11.4 类加载的顺序



```
1. 父类静态方法
2. 子类静态方法
3. 父类普通方法
4. 父类构造函数
5. 子类普通方法
6. 子类构造函数
```

##### 11.5 双亲委派机制

https://www.jianshu.com/p/9b2d43c9a09a

https://www.cnblogs.com/aspirant/p/8991830.html

```
1. 启动类加载器  Bootstrap ClassLoader ：

启动类加载器,负责加载java基础类，对应的文件是%JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等

2. 拓展类加载器  Extension ClassLoader：

对应的文件是 %JRE_HOME/lib/ext 目录下的jar和class等

3. 应用类加载器  App ClassLoader：

对应的文件是应用程序classpath目录下的所有jar和class等


4. 自定义加载类

加载一个类的时候，先用父类去加载，如果父类加载没有，再给子类加载
```



**自定义一个类加载器**

https://blog.csdn.net/huazai30000/article/details/85296671

```
public class MyClassLoader extends ClassLoader {
    //指定路径
    private String path ;
 
 
    public MyClassLoader(String classPath){
        path=classPath;
    }
 
    /**
     * 重写findClass方法
     * @param name 是我们这个类的全路径
     * @return
     * @throws ClassNotFoundException
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class log = null;
        // 获取该class文件字节码数组
        byte[] classData = getData();
 
        if (classData != null) {
            // 将class的字节码数组转换成Class类的实例
            log = defineClass(name, classData, 0, classData.length);
        }
        return log;
    }
 
    /**
     * 将class文件转化为字节码数组
     * @return
     */
    private byte[] getData() {
 
        File file = new File(path);
        if (file.exists()){
            FileInputStream in = null;
            ByteArrayOutputStream out = null;
            try {
                in = new FileInputStream(file);
                out = new ByteArrayOutputStream();
 
                byte[] buffer = new byte[1024];
                int size = 0;
                while ((size = in.read(buffer)) != -1) {
                    out.write(buffer, 0, size);
                }
 
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    in.close();
                } catch (IOException e) {
 
                    e.printStackTrace();
                }
            }
            return out.toByteArray();
        }else{
            return null;
        }
 
 
    }
}
```



**打破双亲委派机制**

https://www.jianshu.com/p/9b2d43c9a09a

https://cloud.tencent.com/developer/article/1706851

https://www.cnblogs.com/cl-rr/p/9081817.html

```
1. JDBC，通过使用线程上下午类加载器打破

2. Tomacat , 每一个应用都会生成 webAppClassLoader
```



##### 11.6  垃圾回收算法

https://blog.csdn.net/weixin_43213517/article/details/89853530



| 算法     | 优点         | 缺点     |
| :------- | ------------ | -------- |
| 标记清除 |              | 产生碎片 |
| 标记整理 | 不会产生碎片 |          |
| 复制算法 |              |          |
| 分代回收 |              |          |



##### 11.7 垃圾回收器



```
串行
series
seriesOld

并行
parNew
pallre

cms

G1
```



##### 11.8  JVM调优

```

```





##### 11.9  老年代担保机制

https://blog.csdn.net/weixin_38106322/article/details/108893760

```
当新生代被分配了大对象(该对象大小可以通过参数设置)，或者经过Minor GC后，存活下来的对象，Survivor区放不下，那么这些对象都会被分配到老年代。

老年代想担保就能担保？
老年代空间也是有限的，既然不是无限大，那么老年代在担保前也得自己掂量下，自己是不是吃的下那些要分配给自己的对象。

老年代想要担保需要遵守什么规则？
在执行任何一次Minor GC前，JVM都会检查一下老年代的的可用内存空间，然后和新生代中的所有对象的大小总和做个比较，如果大于新生代中的所有对象的大小总和，那么就可以保证Minor GC后，即使新生代中所有的对象都存活下来，Survivor区放不下，老年代也是能够完全分配下这些对象的。如果老年代的的可用内存空间是小于新生代中的所有对象的大小总和的，那么就要继续走第二步的判断。
第二步判断，要看看是否设置了“-XX:-HandlePromotionFailure”参数，该参数的作用在于会多加一步判断规则：判断老年代的的可用内存空间是否大于之前每一次Minor GC后进入老年代的对象的平均大小。如果不加这个参数或者这个参数判断失败，同时老年代的的可用内存空间小于新生代中的所有对象的大小总和，就会直接进行Full GC，尽量先腾出一些老年代空间来，然后再触发Minor GC，尽最大努力防止出现OOM。如果“-XX:-HandlePromotionFailure”参数判断是成功的，那么就走第三步。
第三步就可以试着进行Minor GC了，毕竟该做的判断做了和该满足的条件都有了，此时Minor GC后，如果存活的对象大小小于Survivor区的大小，那么存活的对象直接进入Survivor区。如果存活的对象大小大于Survivor区的大小，却小于老年代大小，那么存活的对象直接进入老年代。最极端的情况就是存活的对象大小大于Survivor区的大小，同时也大于老年代大小，那么此时机会触发一次Full GC，对老年代和新生代统一做一次垃圾回收，腾出空间，方便让Minor GC后存活的对象可以进入老年代。最差的情况就是即使经过了Full GC，老年代空间也还是不够，那么就会爆出OOM了。
————————————————

```



```
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlerPromotionFailure设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，将尝试着进行一次Monitor GC，尽管这次GC是有风险的。如果小于，或者HandlerPromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC了。

上述所说的冒险到底是冒的什么险呢？

前面提到过，新生代使用复制收集算法，但是为了内存利用率。只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况是内存回收之后，新生代中所有的对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现HandlerPromotionFailure失败，那就只好在失败后重新发起一次FULL GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是将HandlerPromotionFailure开关打开，避免Full GC过于频繁。
```



##### 11.10 介绍一下分代回收机制

```
当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则。而分代收集理论，建立在如下三个分代假说之上，即弱分代假说、强分代假说、跨代引用假说。依据分代假说理论，垃圾回收可以分为如下几类：
1. 新生代收集：目标为新生代的垃圾收集。

2. 老年代收集：目标为老年代的垃圾收集，目前只有CMS收集器会有这种行为。

3. 混合收集：目标为整个新生代及部分老年代的垃圾收集，目前只有G1收集器会有这种行为。

4. 整堆收集：目标为整个堆和方法区的垃圾收集。

加分回答

HotSpot虚拟机内置了很多垃圾收集器，其中针对新生代的垃圾收集器有Serial、ParNew、Parallel Scavenge，针对老年代的垃圾收集器有CMS、Serial Old、Parallel Old。此外，HotSpot还内置了面向整堆的G1收集器。在上述收集器中，常见的组合方式有：

1. Serial + Serial Old，是客户端模式下常用的收集器。

2. ParNew + CMS，是服务端模式下常用的收集器。

3. Parallel Scavenge + Parallel Old，适用于后台运算而不需要太多交互的分析任务。

【延伸阅读】

三个分代假说：

1. 弱分代假说：绝大多数对象都是朝生夕灭的。

2. 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。

3. 跨代引用假说：跨代引用相对于同代引用来说只占极少数。

前两条假说奠定了多款常用垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。根据这两条假说，设计者一般至少会把Java堆划分为新生代和老年代两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

第三条假说是根据前两条假说推理得出的隐含结论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。
```



##### 11.11 内存溢出OOM

```
【得分点】

增加内存、错误日志、代码走查、内存查看工具

【参考答案】

标准回答

内存溢出，简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。引起内存溢出的原因有很多种，常见的有以下几种：

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

2. 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；

3. 代码中存在死循环或循环产生过多重复的对象实体；

4. 使用的第三方软件中的BUG；

5. 启动参数内存值设定的过小。

内存溢出的解决方案：

· 第一步，修改JVM启动参数，直接增加内存。

· 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。

· 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。

· 第四步，使用内存查看工具动态查看内存使用情况。

加分回答

除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。

1. Java堆溢出

Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

2. 虚拟机栈和本地方法栈溢出

HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。

3. 方法区和运行时常量池溢出

方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用、基于OSGi的应用等。

在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法去的一部分，所以上述问题在常量池中也同样会出现。而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免。

4. 本地直接内存溢出

直接内存的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值一致。如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常。
```



##### 11.12 CMS

```
CMS垃圾回收器设计目的：为了避免「老年代 GC」出现「长时间」的卡顿（Stop The World）

CMS垃圾回收器回收过程：初始标记、并发标记、并发预处理、重新标记和并发清除。初始标记以及重新标记这两个阶段会Stop The World

CMS垃圾回收器的弊端：会产生内存碎片&&需要空间预留：停顿时间是不可预知的

并发预处理，是为了减少下一个阶段的处理时间，对发生了变化的对象进行标记（dirty）
```



##### 11.13

##### 11.14

##### 11.15  算法稳定性

https://www.cnblogs.com/lqminn/p/3642027.html

https://www.cnblogs.com/Leophen/p/11397731.html

http://www.javashuo.com/article/p-cqlytcrs-go.html

https://www.jianshu.com/p/a5b5b5c4ee0f



#### 12 Redis

##### 12.1 常见的数据结构

```
【得分点】

五种常用数据类型

【参考答案】

标准回答

它主要提供了5种数据类型：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。Redis还提供了Bitmap、HyperLogLog、Geo类型，但这些类型都是基于上述核心数据类型实现的。5.0版本中，Redis新增加了Streams数据类型，它是一个功能强大的、支持多播的、可持久化的消息队列。

1. string可以存储字符串、数字和二进制数据，除了值可以是String以外，所有的键也可以是string，string最大可以存储大小为512M的数据。

2. list保证数据线性有序且元素可重复，它支持lpush、blpush、rpop、brpop等操作，可以当作简单的消息队列使用，一个list最多可以存储2^32-1个元素。

3. hash的值本身也是一个键值对结构，最多能存储2^32-1个元素。

4. set是无序不可重复的，它支持多个set求交集、并集、差集，适合实现共同关注之类的需求，一个set最多可以存储2^32-1个元素。

5. zset是有序不可重复的，它通过给每个元素设置一个分数来作为排序的依据，一个zset最多可以存储2^32-1个元素。

加分回答

每种类型支持多个编码，每一种编码采取一个特殊的结构来实现，各类数据结构内部的编码及结构：

1. string：编码分为int、raw、embstr。int底层实现为long，当数据为整数型并且可以用long类型表示时可以用long存储。embstr底层实现为占一块内存的SDS结构，当数据为长度不超过32字节的字符串时，选择以此结构连续存储元数据和值。raw底层实现为占两块内存的SDS，用于存储长度超过32字节的字符串数据，此时会在两块内存中分别存储元数据和值。

2. list：编码分为ziplist、linkedlist、quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表，当元素数量小于512且所有元素长度都小于64字节时，使用这种结构来存储。linkedlist底层实现为双端链表，当数据不符合ziplist条件时，使用这种结构存储。3.2版本之后list采用quicklist的快速列表结构来代替前两种。

3. hash：编码分为ziplist、hashtable两种。其中ziplist底层实现为压缩列表，当键值对数量小于512，并且所有的键值长度都小于64字节时使用这种结构进行存储。hashtable底层实现为字典，当不符合压缩列表存储条件时，使用字典进行存储。

4. set：编码分为inset、hashtable。intset底层实现为整数集合，当所有元素都是整数值且数量不超过512个时使用该结构存储，否则使用字典结构存储。

5. zset：编码分为ziplist、skiplist。当元素数量小于128，并且每个元素长度都小于64字节时，使用ziplist压缩列表结构存储，否则使用skiplist的字典+跳表的结构存储。

【延伸阅读】

Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串（Simple Dynamic String），即SDS的抽象类型，并将SDS用作Redis的默认字符串表示。每个sds.h/sdshdr结构表示一个SDS值，它有三个属性，这里我们举个例子：

· free属性值为0，代表这个SDS没有被分配任何未使用空间；

· len属性值为5，代表这个SDS存了一个五字节长的字符串；

· buf属性是一个char类型的数组，数组的前五个字节分别保存了‘H’、‘e’、‘l’、‘l’、‘o’ 五个字符，而最后一个字节则保存了空字符‘\0’。

SDS遵循C字符串以空字符结尾的惯例，保存空字符的一字节空间不计算在SDS的len属性中。为空字符串分配1字节的额外空间以及添加空字符到字符串末尾等操作都是由SDS函数自动完成的，所以这个空字符串对于SDS的使用者来说完全透明。遵循空字符串的好处是，SDS可以直接重用一部分C字符串函数库里的函数。


```



###### String 

http://t.zoukankan.com/buguge-p-13477151.html

```
底层结构，SDS ，动态字符串

1. 安全性高，不会造成缓冲区溢出
2. 获取字符串长度的复杂度为O(1)
3. 可以保存文本和二进制数据
4. 减少修改字符串带来的内存重新分配：

   空间预分配
   惰性分配
   
常用命令

set(key, value)：给数据库中名称为key的string赋予值value
get(key)：返回数据库中名称为key的string的value
getset(key, value)：给名称为key的string赋予上一次的value
mget(key1, key2,…, key N)：返回库中多个string的value
setnx(key, value)：添加string，名称为key，值为value
setex(key, time, value)：向库中添加string，设定过期时间time
mset(key N, value N)：批量设置多个string的值
msetnx(key N, value N)：如果所有名称为key i的string都不存在
incr(key)：名称为key的string增1操作
incrby(key, integer)：名称为key的string增加integer
decr(key)：名称为key的string减1操作
decrby(key, integer)：名称为key的string减少integer
append(key, value)：名称为key的string的值附加value
substr(key, start, end)：返回名称为key的string的value的子串


使用场景

缓存
限流，实现访问频率限制: 实现访问者 $ip 在一定的时间 $time 内只能访问 $limit 次. RedisLimiter 
计数器
分布式锁
分布式session


```

Hash

```
hset(key, field, value)：向名称为key的hash中添加元素field
hget(key, field)：返回名称为key的hash中field对应的value
hmget(key, (fields))：返回名称为key的hash中field i对应的value
hmset(key, (fields))：向名称为key的hash中添加元素field 
hincrby(key, field, integer)：将名称为key的hash中field的value增加integer
hexists(key, field)：名称为key的hash中是否存在键为field的域
hdel(key, field)：删除名称为key的hash中键为field的域
hlen(key)：返回名称为key的hash中元素个数
hkeys(key)：返回名称为key的hash中所有键
hvals(key)：返回名称为key的hash中所有键对应的value
hgetall(key)：返回名称为key的hash中所有的键（field）及其对应的value


使用场景：

存储用户信息
存储商品规格


```



###### set

```
sadd(key, member)：向名称为key的set中添加元素member
srem(key, member) ：删除名称为key的set中的元素member
spop(key) ：随机返回并删除名称为key的set中一个元素
smove(srckey, dstkey, member) ：移到集合元素
scard(key) ：返回名称为key的set的基数
sismember(key, member) ：member是否是名称为key的set的元素
sinter(key1, key2,…key N) ：求交集
sinterstore(dstkey, (keys)) ：求交集并将交集保存到dstkey的集合
sunion(key1, (keys)) ：求并集
sunionstore(dstkey, (keys)) ：求并集并将并集保存到dstkey的集合
sdiff(key1, (keys)) ：求差集
sdiffstore(dstkey, (keys)) ：求差集并将差集保存到dstkey的集合
smembers(key) ：返回名称为key的set的所有元素
srandmember(key) ：随机返回名称为key的set的一个元素

使用场景

赞，踩
标签
好友关系


```



###### sortedSet

```
使用场景

排行榜
```

说一说zset**类型的底层数据结构**

```
【得分点】

ziplist、skiplist

【参考答案】

标准回答

zset底层的存储结构包括ziplist或skiplist，在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist，其他时候使用skiplist。

当ziplist作为zset的底层存储结构时候，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。

当skiplist作为zset的底层存储结构的时候，使用skiplist按序保存元素及分值，使用dict来保存元素和分值的映射关系。

加分回答

压缩列表是Redis为了节约内存而开发的，它是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者一个整数值。一个压缩列表的重要组成部分包括zlbytes、zltail、zllen、entryX、zlend，其类型长度以及用途如下表所示：

属性

类型

长度

说明

zlbytes

uint32_t

4字节

压缩列表占用的内存字节数；

zltail

uint32_t

4字节

压缩列表表尾节点距离列表起始地址的偏移量（单位字节）；

zllen

uint16_t

2字节

压缩列表包含的节点数量，等于UINT16_MAX时，需遍历列表计算真实数量；

entryX

列表节点

不固定

压缩列表包含的节点，节点的长度由节点所保存的内容决定；

zlend

uint8_t

1字节

压缩列表的结尾标识，是一个固定值0xFF；

跳跃表的查找复杂度为平均O(logN)，最坏O(N)，效率堪比红黑树，却远比红黑树实现简单。跳跃表是在链表的基础上，通过增加索引来提高查找效率的。

有序链表插入、删除的复杂度为O(1)，而查找的复杂度为O(N)。跳跃表从有序链表中选取部分节点，组成一个新链表，并以此作为原始链表的一级索引。再从一级索引中选取部分节点，组成一个新链表，并以此作为原始链表的二级索引。以此类推，可以有多级索引。跳跃表的实现主要涉及2个结构体：zskiplist、zskiplistNode。zskiplist有指向头尾节点的指针，以及列表的长度，列表中最高的层级。zskiplistNode的头节点是空的，它不存储任何真实的数据，它拥有最高的层级，但这个层级不记录在zskiplist之内。

【延伸阅读】

有序链表插入、删除的复杂度为O(1)，而查找的复杂度为O(N)。例：若要查找值为60的元素，需要从第1个元素依次向后比较，共需比较6次才行，如下图：

跳跃表是从有序链表中选取部分节点，组成一个新链表，并以此作为原始链表的一级索引。再从一级索引中选取部分节点，组成一个新链表，并以此作为原始链表的二级索引。以此类推，可以有多级索引，如下图：


跳跃表在查找时，优先从高层开始查找，若next节点值大于目标值，或next指针指向NULL，则从当前节点下降一层继续向后查找，这样便可以提高查找的效率了。

跳跃表的实现主要涉及2个结构体：zskiplist、zskiplistNode，它们的关系如下图所示：


其中，蓝色的表格代表zskiplist，红色的表格代表zskiplistNode。zskiplist有指向头尾节点的指针，以及列表的长度，列表中最高的层级。zskiplistNode的头节点是空的，它不存储任何真实的数据，它拥有最高的层级，但这个层级不记录在zskiplist之内。


```



###### List

```
常用命令

rpush(key, value)：在名称为key的list尾添加一个值为value的元素
lpush(key, value)：在名称为key的list头添加一个值为value的 元素
llen(key)：返回名称为key的list的长度
lrange(key, start, end)：返回名称为key的list中start至end之间的元素
ltrim(key, start, end)：截取名称为key的list
lindex(key, index)：返回名称为key的list中index位置的元素
lset(key, index, value)：给名称为key的list中index位置的元素赋值
lrem(key, count, value)：删除count个key的list中值为value的元素
lpop(key)：返回并删除名称为key的list中的首元素
rpop(key)：返回并删除名称为key的list中的尾元素
blpop(key1, key2,… key N, timeout)：lpop命令的block版本。
brpop(key1, key2,… key N, timeout)：rpop的block版本。
rpoplpush(srckey, dstkey)：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部

使用场景

```



###### 跳跃表



###### 布隆过滤



```
public class BloomFilterTest {
 
    private static final int capacity = 1000000;
    private static final int key = 999998;
 
    private static BloomFilter<Integer> bloomFilter = BloomFilter.create(Funnels.integerFunnel(), capacity);
 
    static {
        for (int i = 0; i < capacity; i++) {
            bloomFilter.put(i);
        }
    }
 
    public static void main(String[] args) {
        /*返回计算机最精确的时间，单位微妙*/
        long start = System.nanoTime();
 
        if (bloomFilter.mightContain(key)) {
            System.out.println("成功过滤到" + key);
        }
        long end = System.nanoTime();
        System.out.println("布隆过滤器消耗时间:" + (end - start));
        int sum = 0;
        for (int i = capacity + 20000; i < capacity + 30000; i++) {
            if (bloomFilter.mightContain(i)) {
                sum = sum + 1;
            }
        }
        System.out.println("错判率为:" + sum);
    }
}

成功过滤到999998
布隆过滤器消耗时间:215518
错判率为:318
```



##### 12.2  常用命令



```

```

##### 12.3 RDB和AOF

```
重写的过程
```



##### 12.4 redis缓存和mysql数据库数据一致性如何保证

https://baijiahao.baidu.com/s?id=1705768960173495525&wfr=spider&for=pc

如果要求最终一致性的，还是实时一致性，实时一致性的建议不要用缓存

**为什么不推荐更新缓存而是删除缓存**

```
1. 只删除缓存不更新缓存

  
```

优秀方案，**先更新数据库，再删除缓存：**

```
缺点： 1.删除缓存失败，导致数据不一致 2. 存在极端情况，概率低，读到了一个旧值，把旧值设置了缓存，中间有个写操作删除缓存，读比写快得多，所以这种几乎不会出现
解决办法 ： 1.消息队列重试，代码入侵性强
```



##### 12.5  集群模式



```
1. 主从模式 ：会出现分布式锁不一致
2. 哨兵模式 ：
3. 集群模式 ： cluster ，CRC16,16384
```

##### 12.6  redis 3 种集群方案

https://blog.csdn.net/QQ1006207580/article/details/103243281

https://www.cnblogs.com/pingyeaa/p/11294773.html

https://www.cnblogs.com/kaleidoscope/p/9630316.html

https://www.cnblogs.com/phyger/p/14277330.html

**cluster**

**原理**

```
1.把16384槽按照节点数量进行平均分配，由节点进行管理
2.对每个key按照CRC16规则进行hash运算
3.把hash结果对16383进行取余
4.把余数发送给Redis节点
5.节点接收到数据，验证是否在自己管理的槽编号的范围
    如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果
    如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中
```

协议**goosip**

https://zhuanlan.zhihu.com/p/299357218

```
病毒扩散协议
```



**codis**

```

```



##### 12.7 pipline是全双工还是半双工



##### 12.8 缓存雪崩

```
1. 设置随机过期时间
2. 使用分布式锁，高并发场景不建议
3. 使用消息队列
4. 设置key 永远不失效
5. 使用多级缓存
```

##### 12.9 缓存穿透

```
用户大量并发请求的数据(key)对应的数据在redis和数据库中都不存在，导致尽管数据不存在但还是每次都会进行查DB。

1. 从DB中查询出来数据为空，也进行空数据的缓存，避免DB数据为空也每次都进行数据库查询，设定过期时间；
2. 使用布隆过滤器，但是会增加一定的复杂度及存在一定的误判率；


【得分点】

    问题原因、解决方案

【参考答案】

标准回答

缓存穿透：

· 问题描述：

客户端查询根本不存在的数据，使得请求直达存储层，导致其负载过大，甚至宕机。出现这种情况的原因，可能是业务层误将缓存和库中的数据删除了，也可能是有人恶意攻击，专门访问库中不存在的数据。

· 解决方案：

1. 缓存空对象：存储层未命中后，仍将空值存入缓存层，客户端再次访问数据时，缓存层直接返回空值。

2. 布隆过滤器：将数据存入布隆过滤器，访问缓存之前以过滤器拦截，如果数据不存在则直接返回空值。

缓存击穿：

· 问题描述：

一份热点数据，它的访问量非常大。在其缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。

· 解决方案：

1. 永不过期：热点数据不设置过期时间，所以不会出现上述问题，这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现该数据逻辑过期时，使用单独的线程重建缓存。

2. 加互斥锁：对数据的访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。

缓存雪崩：

· 问题描述：

在某一时刻，缓存层无法继续提供服务，导致所有的请求直达存储层，造成数据库宕机。可能是缓存中有大量数据同时过期，也可能是Redis节点发生故障，导致大量请求无法得到处理。

· 解决方案：

1. 避免数据同时过期：设置过期时间时，附加一个随机数，避免大量的key同时过期。

2. 启用降级和熔断措施：在发生雪崩时，若应用访问的不是核心数据，则直接返回预定义信息/空值/错误信息。或者在发生雪崩时，对于访问缓存接口的请求，客户端并不会把请求发给Redis，而是直接返回。

3. 构建高可用的Redis服务：采用哨兵或集群模式，部署多个Redis实例，个别节点宕机，依然可以保持服务的整体可用。
```

##### 12.10 事务

```
Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：

批量操作在发送 EXEC 命令前被放入队列缓存。
收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。
一个事务从开始到执行会经历以下三个阶段：

开始事务。
命令入队。
执行事务。

单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。
```

##### 12.11 生产中禁用的命令



```
Redis 是单线程处理请求操作，如果我们执行一些涉及大量操作、耗时长的命令，就会严重阻塞主线程，导致其它请求无法得到正常处理。

KEYS：该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；

❝
应该使用 SCAN 来代替，分批返回符合条件的键值对，避免主线程阻塞。

FLUSHALL：删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；

FLUSHDB，删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。

❝
加上 ASYNC 选项，让 FLUSHALL，FLUSHDB 异步执行。

我们也可以直接禁用，用rename-command命令在配置文件中对这些命令进行重命名，让客户端无法使用这些命令。

慎用 MONITOR 命令
MONITOR 命令会把监控到的内容持续写入输出缓冲区。

如果线上命令的操作很多，输出缓冲区很快就会溢出了，这就会对 Redis 性能造成影响，甚至引起服务崩溃。

所以，除非十分需要监测某些命令的执行（例如，Redis 性能突然变慢，我们想查看下客户端执行了哪些命令）我们才使用。

慎用全量操作命令
比如获取集合中的所有元素（HASH 类型的 hgetall、List 类型的 lrange、Set 类型的 smembers、zrange 等命令）。

这些操作会对整个底层数据结构进行全量扫描 ，导致阻塞 Redis 主线程。

❝
码哥，如果业务场景就是需要获取全量数据咋办？

有两个方式可以解决：

使用 SSCAN、HSCAN等命令分批返回集合数据；
把大集合拆成小集合，比如按照时间、区域等划分。
```

##### 12.12 运维规范

```
使用 Cluster 集群或者哨兵集群，做到高可用；
实例设置最大连接数，防止过多客户端连接导致实例负载过高，影响性能。
不开启 AOF 或开启 AOF 配置为每秒刷盘，避免磁盘 IO 拖慢 Redis 性能。
设置合理的 repl-backlog，降低主从全量同步的概率
设置合理的 slave client-output-buffer-limit，避免主从复制中断情况发生。
根据实际场景设置合适的内存淘汰策略。
使用连接池操作 Redis。
```



#### 13. Es

##### 13.1  为什么那么快

##### 13.2  节点类型

##### 13.3   写的过程

##### 13.4  读的过程

##### 13.5  解决深分页的问题

https://shuen.blog.csdn.net/article/details/106659019?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link

https://www.cnblogs.com/sanduzxcvbnm/p/12085212.html

```
注意：当我们使用search_after时，from值必须设置为0或者-1。

search_after不是自由跳转到随机页面而是并行scroll多个查询的解决方案。 它与scroll API非常相似，但与它不同，search_after参数是无状态的，它始终针对最新版本的搜索器进行解析。 因此，排序顺序可能会在步行期间发生变化，具体取决于索引的更新和删除。
```

13.6

13.7

13.8

13.9



#### 14 kafka

https://blog.csdn.net/weixin_39963341/article/details/112222097

##### 14.1 基本概念

```
1. broker

2. Topic

3. product

4. consume

5. consume group

6. p

7. ISR

8. OSR


```

##### 14.2  为啥那么快

```
1. 纯内存操作
2. 顺序寻址
3. 批量处理
4. 零拷贝，之前是四次
```





##### 14.3 如何保证消息不丢失



```
1. 生产者

ack, 0 leader节点
异步改为同步
重试机制，死信队列,失败了添加到失败列表

2. 消费者

手动提交offerset

3. broker
```



##### 14.4 如何保证消息的顺序性

```
1. 发到同一个分区
2. 使用key
```



##### 14.5 如何处理消息堆积

##### 14.6 如何实现幂等性

https://www.cnblogs.com/smartloli/p/11922639.html

![img](https://img2018.cnblogs.com/blog/666745/201911/666745-20191124145503342-729193742.png)



Kafka为了实现幂等性，它在底层设计架构中引入了ProducerID和SequenceNumber。那这两个概念的用途是什么呢？

- ProducerID：在每个新的Producer初始化时，会被分配一个唯一的ProducerID，这个ProducerID对客户端使用者是不可见的。
- SequenceNumber：对于每个ProducerID，Producer发送数据的每个Topic和Partition都对应一个从0开始单调递增的SequenceNumber值。

 当Producer发送消息(x2,y2)给Broker时，Broker接收到消息并将其追加到消息流中。此时，Broker返回Ack信号给Producer时，发生异常导致Producer接收Ack信号失败。对于Producer来说，会触发重试机制，将消息(x2,y2)再次发送，但是，由于引入了幂等性，在每条消息中附带了PID（ProducerID）和SequenceNumber。相同的PID和SequenceNumber发送给Broker，而之前Broker缓存过之前发送的相同的消息，那么在消息流中的消息就只有一条(x2,y2)，不会出现重复发送的情况。

##### 14.7 kafka消费者的偏移量存在哪里

```
segment 中的index 和 log
```



##### 14.8 kafka 重平衡

##### 14.9

#### 15. 设计情景

https://www.cnblogs.com/xiaonian8/p/14111463.html

https://blog.csdn.net/linuxguitu/article/details/111676210

##### 15.1 单点登录SSO

##### 15.2 设计一个分布式限流系统

##### 15.3 设计一个数据库引擎

##### 15.4 设计一个注册中心

##### 15.5 设计一门语言

##### 15.6 设计一个秒杀系统

##### 15.7 设计一个网关

##### 15.8 跨机房的网络延迟怎么解决。

##### 15.9 短URL实现

https://www.cnblogs.com/codehello/articles/13986247.html

##### 15.10 设计一个微信抢红包

##### 15.11 给一个场景：1个2000w的大V发了一条劲爆的微博消息，怎么去设计

##### 15.12 订单号不能重复，你怎么设计生成订单号？

##### 15.13 rpc接口的超时时间时如何设置

##### 15.14 服务容灾是如何做的？

15.15

15.16

15.17

15.18

15.19



#### 16. linux

##### 16.1 常用命令

```

```



##### 16.2

##### 16.3

##### 16.4

##### 16.5

##### 16.6

16.7

16.8

16.9

#### 17 云原生

##### 17.1 什么是云原生

![img](https://pic3.zhimg.com/80/v2-7913f6e74f38682804d36f88c4fb4882_720w.jpg)

```
云原生是一种构建和运行应用程序的方法，是一套技术体系和方法论
DevOps+持续交付+微服务+容器。

云元素的四要素
微服务：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。

微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。

容器化：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。

DevOps：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。

持续交付：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。
```

##### **17.2**  基本概念

```
kubectl 命令行工具
master
apiServer
shedual
kubelet
kubeproxy
```

##### 17.3 k8s常用命令



17.4

17.5

17.6

17.7

17.8

17.9

17.10

17.11

17.12

17.13

17.14

17.15

17.16

17.17

17.18

17.19



#### 18. 测试

##### 18.1 压力测试工具

Locust

18.2

18.3

18.4

18.5

18.6

18.7

#### 19 zookeeper

19.1

19.2

19.3

19.4

19.5
