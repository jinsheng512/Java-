#### 1. 计算机系统

##### 1.1  lvs四层转发和nginx七层转发的区别？

https://www.cnblogs.com/guixia621/p/6426765.html

#### 2. 计算机网络

##### 2.1  七层协议合四层协议

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQUkM2ib9WWjiabWHbbF0B7Sq5B0RAMJwaTicopuxPlRia1x3uTEbBYD1SD4nLQM14EOibHJQV6pTjZUqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQUkM2ib9WWjiabWHbbF0B7SqiaAu3Unibiao8IWH1xIowmLQkSZmPjl3lXMznXicZmz98bbvZQFwnjpicDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





###### 常见面试题

**三次握手**的过程

![图片](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD58Npf1AOxttKsHPFl4aOQ54Znzk6P3mic47cYsh2RLgQMibV4I8iaKbZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**为什么要三次握手**

```

1. 保证双方发送接收功能都正常
2. 握手的重点就是同步初始序列号
```

**SYN 超时了怎么处理？**

```
也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？
超时重传

在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。
```

**SYN Flood 攻击**

```
你看到没 SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server 发 SYN 但就是不回 server。

解决方案：

1. tcp_syncookies

2. 或者调整 tcp_synack_retries 减少重试的次数，设置 tcp_max_syn_backlog 增加 SYN 队列数，设置 tcp_abort_on_overflow SYN 队列满了直接拒绝连接。
```

**四次挥手**的过程

![图片](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDfa4qx2k7PGicQrGqVPIbqNbIxmbzEicT8F1mtgFbGfmxjGWlricibfgy1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**为什么要四次握手**

```
主动关闭方的状态是 FIN_WAIT_1 到 FIN_WAIT_2 然后再到 TIME_WAIT，而被动关闭方是 CLOSE_WAIT 到 LAST_ACK。

确保双方都关闭了，四次挥手是因为 TCP 是全双工协议，因此双方都得说拜拜。

那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？

```

**为什么要有TimeWait**

```
1. 服务器没有接收到 ack，可以重传fin

2. 为了保证最后一个ACK正常的丢失，因为不确认对方是否收到，需要等1个MSL，至于另一个MSL，能找到比较信服的解释就是被动关闭的一方在收到ACK的那一刻之前重发了FIN，为了保证这个FIN正常丢失，需要再等1个MSL
```

**TCP 和 UDP区别**

```
1. 可靠和不可靠
2. 传播速度

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
```

**TCP 是如何保证可靠性的**

```
1. 确认序列号
2. 校验和
3. 超时重传机制
4. 拥塞控制
5. 流量控制
6. 三次握手和四次挥手
```

**TimeWait 过多解决办法**

```
如果服务器出了异常，百分之八九十都是下面两种情况：

1.服务器保持了大量TIME_WAIT状态

2.服务器保持了大量CLOSE_WAIT状态

因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着应用程序可能返回大量Too Many Open Files异常。

先来说一说长连接和短连接，在HTTP1.1协议中，有个 Connection 头，Connection有两个值，close和keep-alive，这个头就相当于客户端告诉服务端，服务端你执行完成请求之后，是关闭连接还是保持连接。如果服务器使用的短连接，那么每次客户端请求后，服务器都会主动发送FIN关闭连接。最后进入time_wait状态。可想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态。让服务器能够快速回收和重用那些TIME_WAIT的资源，可以修改内核参数。

修改/etc/sysctl.conf如下：

#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间

net.ipv4.tcp_syn_retries=2

#net.ipv4.tcp_synack_retries=2

#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒

net.ipv4.tcp_keepalive_time=1200

net.ipv4.tcp_orphan_retries=3

#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间

net.ipv4.tcp_fin_timeout=30

#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_syn_backlog = 4096

#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭

net.ipv4.tcp_syncookies = 1

#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭

net.ipv4.tcp_tw_reuse = 1

#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭

net.ipv4.tcp_tw_recycle = 1

##减少超时前的探测次数

net.ipv4.tcp_keepalive_probes=5

##优化网络设备接收队列

net.core.netdev_max_backlog=3000

修改完之后执行/sbin/sysctl -p让参数生效。


```

**closeWait过多解决办法**



```
如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出FIN信号，一般原因都是TCP连接没有调用关闭方法。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行，一定程度上，可以使用TCP的KeepAlive功能，让操作系统替我们自动清理掉CLOSE_WAIT连接。

但是实际上，还是主要是因为我们的程序代码有问题

```

**网络诊断工具**

```
命令行：

```



http**发展史**

```
1.0 ， 短连接
1.1 ， 摘要算法，长连接
2.0 ， 头部压缩
```



##### 2.2 DNS

##### 2.3 CDN

2.4

2.5

2.6

2.7

2.8

2.9

2.10

2.11

2.12

2.13

2.14

2.15

2.16



#### 3. java基础

##### 3.1   break 和 continue 的区别

```

   break， 跳出整个循环
   continue， 跳出当前某一个循环
```



##### 3.2  && 和 || 的使用

##### 3.3 String ,StringBuilder ,StringBuffer的区别

##### 3.4  JDK 各版本 新属性

https://www.cnblogs.com/ulong/p/10212823.html

```
1.7 ：

1.8 ：
接口有默认实现方法了，只需要使用 default关键字即可
Lambda 表达式
Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用

Optional 接口:

Optional<String> optional = Optional.of("bam");
optional.isPresent();           // true
optional.get();                 // "bam"
optional.orElse("fallback");    // "bam"

optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"

Stream 流:
并行Streams
Count 计数
Match 匹配
Map 映射
Sort 排序
Filter 过滤





DateTimeFormatter是不可变的，所以它是线程安全的
https://blog.csdn.net/dxhtostage/article/details/103905994




```

##### 3.5  JDK 1.7  和1.8版本 时间格式化的区别

https://blog.csdn.net/dxhtostage/article/details/103905994

```
SimpleDateFormat是线程不安全的，在并发环境下使用SimpleDateFormat；
DateTimeFormatter是线程安全的，jdk8自带（ java.time.format.DateTimeFormatter）；
Joda time里的DateTimeFormat也是线程安全。
```



##### 3.6 抽象类和接口的区别

##### 3.7 快速失败和安全失败

##### 3.8 i++ 和 ++i 的区别

##### 3.9 包装类Integer.valueof(""),使用了缓存

##### 3.10 类的封装性

```
private ， 同一类中可见
default,   同一包中的类
protect,   不同包中的子类
public ，所有
```

##### 3.11  类的多态性：

##### 3.12 创建对象4种方式

```
  new
  clone
  反序列化
  反射机制
```



##### 3.13 final， finally，finalize的区别

##### 3.14 异常

```
1. 受检异常，IDEA 爆红，
2. 非受检异常
```

##### 3.15 匿名内部类

https://www.cnblogs.com/chenssy/p/3390871.html

```
     1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

     2、匿名内部类中是不能定义构造函数的。

     3、匿名内部类中不能存在任何的静态成员变量和静态方法。

      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

     5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
     
     
      我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。
```

3.16

3.17

3.18

3.19

3.20





#### 4. java高级

##### 4.1 集合

######  解决冲突的方法：

https://www.jianshu.com/p/a343dae4a818

```
 链地址法
 再哈希法
 建立公共溢出区
 开放地址法
```



###### HashMap



https://www.bbsmax.com/A/qVde0aBp5P/

```
1.7 
数组+链表 
put 和 get 的过程：
首先判断集合是否为空，空的话进行初始化，否则根据传进来的key，进行hash，按位异或 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);高低位都进行计算，减少哈希冲突，
如果key为null，放到第一个key位置
如果集合不存在，直接插入
如果集合存在，

安全性，头插法，造成循环，CPU 100%

1.8 数组 + 链表 + 红黑树
 链表大于8的时候转为红黑树
 
 安全性，尾插法，数据覆盖导致不安全
 



```

###### currentHashMap



```
1.7 
sedment + ReetrantLock


```



###### get过程

###### put过程



###### size计算

```
众所周知，concurrenthashmap有很多歌segments，首先遍历segments将每个segment的count加起来作为整个concurrenthashMap的size。如果没有并发的情况下这自然就可以了，但这是多线程的，如果前脚统计完后脚有变化了，这就不准确了，源码中引入了，modCount和两次比较来实现size的确认。具体过程是：

1.进行第一遍遍历segments数组，将每个segemnt的count加起来作为总数，期间把每个segment的modCount加起来sum作为结果是否被修改的判断依据。
这里需要提一下modCount，这个是当segment有任何操作都会进行一次增量操作，代表的是对Segment中元素的数量造成影响的操作的次数，这个值只增不减！！！！只增不减很重要，这样就不会出现一个segment+1，导致modcount+1,而另一个segment-1，即modcount-1 ,从而在统计所有的时候modcount没有变化。

2.size操作就是遍历了两次所有的Segments，每次记录Segment的modCount值，然后将两次的modCount进行比较，如果相同，则表示期间没有发生过写入操作，就将原先遍历的结果返回，如果不相同，则把这个过程再重复做一次，如果再不相同，则就需要将所有的Segment都锁住，然后一个一个遍历了。

3.如果经判断发现两次统计出的modCount并不一致，那就如上所说，要重新启用全部segment加锁的方式来进行count的获取和统计了，这样在此期间每个segement都被锁住，无法进行其他操作，统计出的count自然很准确。

而之所以之所以要先不加锁进行判断，道理很明显，就是不希望因为size操作获取这么多锁，因为获取锁不光占用资源，也会影响其他线程对ConcurrentHash的使用，影响并发情况下程序执行的效率。使用锁要谨慎！

```



##### 4.2 反射



##### 4.3 序列化

##### 4.4

##### 4.5

##### 4.6

##### 4.7









#### 5. 多线程

##### 5.1 线程的生命周期

```
1. 初始
2. 就绪状态
3. 运行状态
4. 中断状态
5. 中止状态
```



##### 5.2  如何优化线程池



```
1. 设置其最大线程，最小线程数，IO密集型，2CPU ，cpu密集型：CPU+1

2. 设置线程的空闲时间，keepTimeAlive

3. 抛弃队列的选择
```



##### 5.3  为什么指令重[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)能优化代码执行速度

https://blog.csdn.net/weixin_37841366/article/details/113086438

```
重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。
```



##### 5.4 线程池原理

7**个核心参数**

```
核心线程数

最大线程数

线程空闲时间

线程空闲时间单位

工作队列

抛弃策略

线程工厂
```

**原理**



```

```

##### 5.5 死锁

https://blog.csdn.net/guaiguaihenguai/article/details/80303835

**四个必须**

```
1. 相互互斥
2. 不可剥夺条件，只能线程自己释放资源
3. 循环等待
4. 占有并且等待
```



**预防死锁**

```
打破其四个必要条件：

1. 一次性申请所有资源，简单安全，但资源利用率低
2. 该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。
3.破坏“不可抢占”条件
      当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。
      该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。
4.破坏“循环等待”条件
     可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源
这样虽然避免了循环等待，但是这种方法是比较低效的，资源的执行速度回变慢，并且可能在没有必要的情况下拒绝资源的访问，比如说，进程c想要申请资源1，如果资源1并没有被其他进程占有，此时将它分配个进程c是没有问题的，但是为了避免产生循环等待，该申请会被拒绝，这样就降低了资源的利用率
```



**防止死锁**

```
    1、如果一个进程的请求会导致死锁，则不启动该进程
    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。
避免死锁的具体实现通常利用银行家算法
```

**死锁解除**

```
如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：
1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。
2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。
    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。
     b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：
    进程的优先级
    进程已运行时间以及运行完成还需要的时间
    进程已占用系统资源
    进程运行完成还需要的资源
    终止进程数目
    进程是交互还是批处理

```



##### 5.6  常见关键字

###### ThreadLocal

https://baijiahao.baidu.com/s?id=1663127810801876375&wfr=spider&for=pc

https://www.freesion.com/article/5698706089/

https://www.cnblogs.com/q540973436/p/13539021.html

https://juejin.cn/post/6844903878870171662 fastThreadLocal



https://blog.csdn.net/ol950919/article/details/108106533

```
底层结构： threadLocalMap
从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置。

ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，那么 ThreadLocalMap 中保存的 key 值就变成了 null，而 Entry 又被 threadLocalMap 对象引用，threadLocalMap 对象又被 Thread 对象所引用，那么当 Thread 一直不终结的话，value 对象就会一直存在于内存中，也就导致了内存泄漏，直至 Thread 被销毁后，才会被回收。

fastThreadLocal 是 ThreadLocal 的替代品，吞吐量更快，内部实现了自动删除，不会存在内存泄露

InheritableThreadLocal

```



```
public class Test {
    public static InheritableThreadLocal threadLocal = new InheritableThreadLocal();
    public static void main(String[] args) throws Exception{
        threadLocal.set("主线程的值");
        System.out.println(threadLocal.get());
        Thread.sleep(3000);
        new Thread( ()-> {
            threadLocal.set("子线程的值");
            System.out.println(threadLocal.get());
        }).start();
        Thread.sleep(3000);
        System.out.println(threadLocal.get());
    }
}

InheritableThreadLocal关键字中子线程会继承父线程存储的数据。子线程可以修改继承的主线程的存储数据，且主线程的存储数据不受影响。

```



###### synchronize



```
底层原理：monitorenter monitorexit


对象头： Hash,分代年龄，锁标志，01,01,00,10  无锁，偏向锁，轻量级锁，重量级锁

同步代码快
同步方法 ACC_SYNCHRONIZED
同步对象
```



###### volitale

https://www.jianshu.com/p/ef8de88b1343 内存屏障

```
只能保证可见性，顺序性，不能保证原子性

　　volatile很好的保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，但是加了这个指令后，会引发两件事情：

　　将当前处理器缓存行的数据写回到系统内存
　　这个写回内存的操作会使得在其他处理器缓存了该内存地址无效什么意思呢？意思就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。
　　
　　顺序性，是通过内存屏障来实现的

```



###### ReetrancLock





#### 6. Spring

##### 6.1 IOC

##### 6.2 AOP

##### 6.3 生命周期

##### 6.4  三级缓存

https://www.cnblogs.com/semi-sub/p/13548479.html

##### 6.5

##### 6.6

##### 6.7

##### 6.8



#### 7. 中间件

7.1

7.2

7.3

7.4

7.5

7.6

7.7



#### 8. 数据库

##### 8.1 Myisam  和 Inodb的区别

##### 8.2 Inodb 的底层原理

##### 8.3 mysql 的执行过程

##### 8.4 事务

###### 事务的四个特性：

```

1. 一致性
2. 隔离性
3. 持久性
4.

```



###### 事务隔离级别

```
1. 读未提交
2. 读已提交
3. 可重复读
4. 串行化
```



###### 多版本控制MVCC

```
快照读
当前读
readview undo 日志 ，读已提交，生成新的快照，可重复读。只用第一个快照

```



##### 8.5 索引 

###### 索引类别

```
1. 聚簇索引
2. 非聚簇索引
3. 覆盖索引
4. 辅助索引
5. 组合索引
6. 

```

###### 索引原理B+树

```

```



##### 8.6 日志



##### 8.7  

8.8

8.9

8.10

8.11

8.12

8.13



#### 9.  设计模式



##### 9.1 单列模式

```
单例模式，防止反射和反序列化漏洞：

修改构造函数：
	private SingletonDemo6() {
		// 防止反射获取多个对象的漏洞
		if (null != instance) {
			throw new RuntimeException();
		}
	}

```



**懒汉模式**

```
 public class Singleton{
 
    private static volitale Singleton instance;
    
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
    
          if(instance == null){
          
              synchronized( Singleton.class){
              
                 if(instance == null){
                 
                    instance = new Singleton();
                 
                 }
              }
          
          }
               return instance;
    }
 
 }
```



**恶汉模式**

```
public class Singleton{

     private static Singleton instance = new Singleton();
     
     private Singleton(){
     
     }
     
     public static Singleton getInstance(){
     
            return instance;
     }

}
```



**静态内部类**



```
  public class Singleton{
  
    private static class SingletonHolder {
    
      private static final Singleton instance = new Singleton();
    
    }
    
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
    
        return SingletonHolder.instance;
    }
  
  }
```



**枚举**





##### 9.2 策略模式



```

```



##### 9.3 适配器模式



```

```



##### 9.4 模板模式

```

```



##### 9.5 原型模式

##### 9.6 观察者模式

##### 9.7

##### 9.8





#### 10. 算法

##### 10.1 反转链表

​    **迭代法**

```
public class Solution{

    public ListNode reverseList(ListNode head){
    
            ListNode next = null;
            ListNode pre = null;
            
            while(head != null){
            
                next = head.next;
                head.next = pre;
                pre = head;
                head = next;
            
            }
           
           return pre;
    
    }

}
```



  **递归法**



##### 10.2 链表是否有环



**快慢指针**

```
public class Solution{

     public boolean hasCycle(ListNode head){
              
              ListNode fast = head;
              ListNode slow = head
     
            while(fast null && fastxt != null){
            
                   fast = fast.next.next;
                   slow = slow.next;
                    
                    if(fast == slow){
                    
                        return true;
                    
                    }
            
            }
     
          return false;
     }

}
```



##### 10.3  二叉树前中后序遍历



```
public class Solutioon{

      public void preOrder(TreeNode root , List<Integer> list){
      
          if(root != null){
          
             list.add(root.val);
             preOrder(root.left,list);
             preOrder(root.right,list);
          
          }
      
      }
      
      
      public void inOrder(TreeNode root, List<Integer> list){
      
      
      }
      
      
      public void postOrder(TreeNode root, List<Integer> list){
      
      
      }

}
```

##### 10.4 二叉树层序遍历



**队列，先进先出**

```
public class Solution{

      public List<List<Integer>> leverOrder(TreeNode root){
      
              List<List<Integer>> res = new ArrayList<List<Integer>>();
      
              LinkerList<TreeNode> queue = new LinkerList<TreeNode>();
              
              queue.add(rooot.val);
              
              while(queue.size()!=0){
              
                  List<Integer> temp = new ArrayList<Integer>();
                  
                  for(int i=0 ;i<queue.size() ;i++){
                  
                      TreeNode  t = queue.remove();
                      temp.add(t.val);
                      if(t.left != null){
                      
                         queue.add(t.left);
                      }
                  
                      if(t.right != null){
                      
                         queue.add(t.right);
                      }
                  }
                  
                  res.add(ttemp);
              
              
              }
              
              return res;
      }

}
```



```
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        //边界条件判断
        if (root == null)
            return new ArrayList<>();
        //队列
        Queue<TreeNode> queue = new LinkedList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        //根节点入队
        queue.add(root);
        //如果队列不为空就继续循环
        while (!queue.isEmpty()) {
            //BFS打印，levelNum表示的是每层的结点数
            int levelNum = queue.size();
            //subList存储的是每层的结点值
            ArrayList<Integer> subList = new ArrayList<>();
            for (int i = 0; i < levelNum; i++) {
                //出队
                TreeNode node = queue.poll();
                subList.add(node.val);
                //左右子节点如果不为空就加入到队列中
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            //把每层的结点值存储在res中，
            res.add(subList);
        }
        return res;
    }
```



##### 10.5 用栈实现队列



```
  public class Solution{
  
       Stack<Integer> A = new Stack<Integer>();
       Stack<Integer> B = new Stack<Integer>();
       
       public void push(int node){
       
             A.push(node);
       
       }
       
       public int pop(){
       
           if(B.size()<= 0){
           
             while( A.size() != 0){
             
                B.push(A.pop());
             }
           }
           
           return B.pop();
       }
  
  }
```





##### 10.6  两数之和



```
  public class Solution{
  
       public int[] twoSum(int[] nums, int target){
       
       
              Map<Integer,Integer> map = new HashMap<Integer,Integer>();
              
              for(int i=0; i< nums.length-1 ;i++)
              {
                   if(map.containsKey(target-nums[i])){
                   
                      return new int[]{map.get(target-nums[i],i)};
                   
                   }else{
                   
                      map.put(nums[i],i)
                   }

              }
       
       
       }
  
  
  }
```



##### 10.7 整数反转



```
   public class Solution{
   
        pubblic int reverseInt(int x){
        
             int res = 0;
             while(x != 0){
             
                 int temp = x / 10 + res * 10;
                 
                 res = temp;
                 x /= 10;
             
             }
             
             return res;
        
        }
   
   
   }
```



##### 10.8  从尾到头打印链表

https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/xie-liao-na-yao-duo-ci-zong-jie-san-chon-exv5/

```
   public class Solution{
   
        public int[] reverseList(ListNode head){
        
         Stack<Integer> stack = new Stack<Integer>();
         
           while(head != null){
           
                 stack.push(head.val);
                 head = head.next;
           }
         
         int[] num = new int[stack.size()];
         
         for(int i = 0 ; i< num.length ;i++){
         
           num[i] = stack.pop();
         
         
         }
         
         return num;
        
        } 
   
   }
```



##### 10.9  替换空格

https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/ti-huan-kong-ge-shuang-zhi-zhen-fa-by-ja-z8rz/

```
   public class Solution{
   
       public String replaceSpace(String str){
       
                 if( str == null){
                 
                    return null;
                 }
                 
                 StringBulider sb = new StringBuilder();
                 
                 for(int i = 0 ; i< str.length(); i++){
                 
                      if(String.valueOf(str.charAt(i)).equals("")){
                      
                         sb.append("%20");
                         
                      }else{
                      
                      
                         sb.append(str.charAt(i))
                      }
                      
                 
                 }
                 
                 return sb.toString();
       
       }
   
   
   }
```



##### 10.10  二分查找算法



```
public class Solution{

      public int twoSearch(int[] nums ,int target){
      
       int left = 0;
       int right = nums.length;
       int mid = 0;
       
       while( left < right){
       
          mid = (left + right )/2;
          
          if(nums[mid] == target){
          
           while(mid != null && mums[mid] = nums[mid-1]){
          
                mid--;
                return mid;
                
          }
          }
         
          
          if(nums[mid] > target){
          
                 hight = mid -1;
          }
           
          if(nums[mid] < target){
          
                 low = mid + 1;
          }
       
       }
      
      
      }

}
```



##### 10.11 合并两个排序的链表



```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        
        if(list1 == null){
            
            return list2;
        }
        
        if(list2 == null){
            
            return list1;
        }
        
        if(list1.val< list2.val){
            
            list1.next = Merge(list1.next,list2);
            return list1;
            
            
        }else{
            
            list2.next = Merge(list1,list2.next);
            return list2;
        }
        
    }
}
```



##### 10.12 跳台阶



```
   public class Solution{
   
       public int jumpFloor(int target){
       
       
            if(target == 1 ){
            
                return 1;
            }
            
            if(target == 2 ){
            
                return 2;
            }
            
            
            int a= 1;
            int b= 2;
            int temp = 0;
            
            for( int i = 3 ;i<= target ;i++){
            
               temp = a;
               a = b;
               b = temp + b;
            
            
            }
            
            
            return b;
       
       }
   
   
   }
```



##### 10.13 设计LRU



```
import java.util.*;


public class Solution {
    /**
     * lru design
     * @param operators int整型二维数组 the ops
     * @param k int整型 the k
     * @return int整型一维数组
     */
    public class Node{
        private int val;
        private int key;
        private Node pre =null;
        private Node next =null;
        private Node(int key,int val){
            this.val=val;
            this.key=key;
        }
    }

    private HashMap<Integer,Node> map = new HashMap();
    private Node head = new Node(-1,-1);  //头节点
    private Node tail = new Node(-1,-1);  //尾节点
    private int k=0;

    public int[] LRU (int[][] operators, int k) {
        // write code here
        this.k = k;
        head.next = tail;
        tail.pre = head;

        int len = (int)Arrays.stream(operators).filter(x->x[0]==2).count();  //获取数组中开头为2（get操作）的元素个数        
        int res[] = new int[len];

        for(int i=0,j=0;i<operators.length;i++){
            if(operators[i][0] == 1){   //获取数组中开头为1（set操作）的元素个数
                set(operators[i][1],operators[i][2]);  //set(key,val)
            }else{   //获取数组中开头为2（get操作）的元素个数
                res[j++] = get(operators[i][1]);  //get(key)
            }
        }
        return res;
    }

    public void set(int key,int val){
        //判断是否存在key 
        Node node = null;
        if(map.containsKey(key)){   //如果已经存在key，将val更新，并删除这个节点，再将node插入到表头
            node = map.get(key);
            node.val = val;
            //删除该结点
            node.next.pre = node.pre;
            node.pre.next = node.next;
            //将node节点提到第一个
            moveToFirst(node);
        }else{  //如果不存在key，先判断是否超出空间，如果超出先在链表和map删除最后一个节点，再将节点插入到表头，并将对应的映射添加到map中
            if(map.size()==k){
                //在map中删除映射到最后一个节点的key
                int keyremove =tail.pre.key;
                map.remove(keyremove);
                //在链表中删除最后一个节点
                tail.pre.pre.next = tail;
                tail.pre = tail.pre.pre;
            }
            node = new Node(key,val);
            //在map中添加对新节点的映射
            map.put(key,node);
            //将节点插入到表头
            moveToFirst(node);

        }
    }

    public int get(int key){
        // 如果不存在key 则返回-1
        // 如果存在key，先将该key的结点删除，然后再将此节点插入到链表的表头
        if(!map.containsKey(key)){
            return -1;
        }else{
            Node node = map.get(key);
            //删除该结点
            node.next.pre = node.pre;
            node.pre.next = node.next;
            //插入到表头
            moveToFirst(node);
            return node.val;
        }
    }
    //将节点插入到表头
    public void moveToFirst(Node node){
            head.next.pre =node;
            node.next =head.next;
            node.pre =head;
            head.next=node;
    }
}
```



##### 10.14 最小K个数



```
   public class Solution{
   
        public List<Intteger> quickSort(int[] put, int k){
        
                ArrayList<Integer> res = new ArrayList<Integer>(k);
                if(k > put.length || k = 0){
                
                     return res;
                }
                
                quickSort11( put,k,0,put.length -1);
                
                return res;
        }
        
        public List<Integer> quickSort11(int[] put,int k ,int left, int right){
        
                 int start = left ;
                 int end = right;
                 
                 while(left < right){
                 
                    while(left < right && put[right] > put[start]){
                    
                      right--;
                    }
                    
                    while(left < right && put[left] < put[start]){
                    
                      left++;
                    }
                    
                    swap(put,left,right);
                 }
                 
                 swap(put ,left,start);
                 
                 if(left > K){
                 
                 quickSort11(put,res,k,start,left-1)
                 
                 }else if(left < K){
                 
                 quickSort11(put,res,k,left+1,end)
                 
                 }else{
                 
                    if(i = 0;i<k;m++){
                    
                       res.add(input[m]);
                    }
                 }
                 
                 
        
        }
        
       private void swap(int[] arr, int i, int j) {
        if (i == j)
            return;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
   
   }
```



```
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        quickSort(arr, 0, arr.length - 1);
        return Arrays.copyOf(arr, k);
    }
    private void quickSort(int[] arr, int l, int r) {
        // 子数组长度为 1 时终止递归
        if (l >= r) return;
        // 哨兵划分操作（以 arr[l] 作为基准数）
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr, i, j);
        }
        swap(arr, i, l);
        // 递归左（右）子数组执行哨兵划分
        quickSort(arr, l, i - 1);
        quickSort(arr, i + 1, r);
    }
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```

```



##### 10.15 丑数

##### 10.16  最大公约数

##### 10.17 大数相加

https://blog.csdn.net/yang10560/article/details/86527911

https://cloud.tencent.com/developer/article/1846675

##### 10.18 旋转数组

##### 10.19 最长回文字串

##### 10.20 最大堆,求最小K个数

我们要保证堆的大小不能超过K，然后遍历数组，因为是最大堆，也就是堆顶元素是堆中最大的，如果遍历的元素小于堆顶元素，就把堆顶元素给移除，然后再把当前遍历的元素加入到堆中，最后在把堆中元素转化为数组即可

```
    public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
        ArrayList<Integer> res = new ArrayList<>(k);
        //根据题意要求，如果K>数组的长度，返回一个空的数组
        if (k > input.length || k == 0)
            return res;
        //创建最大堆
        PriorityQueue<Integer> queue = new PriorityQueue<>((num1, num2) -> num2 - num1);
        //先在堆中放数组的前k个元素
        for (int i = 0; i < k; ++i) {
            queue.offer(input[i]);
        }
        //因为是最大堆，也就是堆顶的元素是堆中最大的，遍历数组后面元素的时候，
        //如果当前元素比堆顶元素大，就把堆顶元素给移除，然后再把当前元素放到堆中，
        for (int i = k; i < input.length; ++i) {
            if (queue.peek() > input[i]) {
                queue.poll();
                queue.offer(input[i]);
            }
        }
        //最后再把堆中元素转化为数组
        for (int i = 0; i < k; ++i) {
            res.add(queue.poll());
        }
        return res;
    }
```



##### 10.21 买卖股票的最好时机

https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=190&&tqId=35181&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking

这是一个典型的动态规划问题。

- **最优子结构**

  在自下而上的递推过程中，我们求得的每个子问题一定是**全局最优解**，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。

- **重复子问题**

  递归地寻找子问题的最优解时，子问题会重叠地出现在子问题里，会有很多重复的计算，动态规划可以保证每个重叠的子问题只会被求解一次。

动态规划解题步骤：

1. 定义子问题
2. 写出子问题的递推关系
3. 确定DP数组的计算顺序

本题中的具体表现为：

```
dp[i]  i天卖出的最大收益``
buy 买进日期``
sell 卖出日期``
dp[i] = 今天卖出日期-最小买进日期;
dp[``0``] = ``0``;
```



```
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int res = 0;
        int len = prices.length;
        int dp =  prices[0];
        int buy = prices[0];
        int sell = prices[0];
        for(int i = 1; i < len; i++){
            sell = prices[i];
            if(sell < buy) buy = sell;
            dp = sell - buy;
            res = Math.max(dp, res);
        }

        return res;
    }
}
```



##### 10.22 判断是否回文

https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2?tpId=190&&tqId=36606&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking

题中说了只有小写字母，最简单的就是使用双指针，一个指向前，一个指向后，两个指针同时往中间走，如果两个指针指向的字符不一样就返回false



```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
       public boolean judge(String str) {
        if (str.length() == 0)
            return true;
        //两个指针，一个从左边开始，一个从右边开始，每次两个
        //指针都同时往中间挪，只要两个指针指向的字符不一样就返回false
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left++) != str.charAt(right--))
                return false;
        }
        return true;
    }
}
```



##### 10.23 二叉树的最大深度



```
   public class Solution{
   
         public int MaxDepth(TreeNode root){
         
         
                int leftDepth = MaxDepth(rooot.left);
                int rightDepth = MaxDepyyh(root.right);
                
                return Matn.max(leftDepth , rightDepth) +1;
         
         
         }
   
   }
```



##### 10.24  判断该二叉树是否是平衡二叉树



```
public class Solution {
    boolean flag = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root==null) return true;
        pre(root);
        return flag;
    }
    public int pre(TreeNode root){
        if(root==null) return 0;
        int left = pre(root.left);
        int right = pre(root.right);
        if(Math.abs(left-right)>1) flag = false;
        return Math.max(left,right)+1;
    }
}
```



##### 10.25 合并K个已排序的链表



```
public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        int size = lists.size();
        if(size == 0){
            return null;
        }
        if(size == 1){
            return lists.get(0);
        }
        ListNode node = lists.get(0);
        for(int i = 1; i < size; i++){
            //参数为 node ，list.size()>2,会多次合并，不可用lists.get(0)
             node = mergeLists(node,lists.get(i));
        }
        return node;
        
    }
    
    public ListNode mergeLists(ListNode node1,ListNode node2){
        ListNode node = new ListNode(-1);
        //操作temp 会有些数据丢失，关联node 同时用node 保存链表
        ListNode temp = node;
        while(node1 != null && node2 != null){
            if(node1.val < node2.val){
                temp.next = node1;
                node1 = node1.next;
            }else{
                temp.next = node2;
                node2 = node2.next;
            }
            //为了后面的连接temp.next = node1 != null ? node1 : node2;
            temp = temp.next;
        }
        //temp 连接多余的node
        temp.next = node1 != null ? node1 : node2;
        return node.next;
    }
}
```



##### 10.26 删除链表的重复元素



```
   public class Solution{
   
         public 
   
   }
```



##### 10.27 多线程打印ABC



###### 使用ReentrantLock

```
public class Solution{

         private static ReentrantLock lock = new Reentrantlock();
         private static int state = 0;
         
         static class ThreadA extends Thread{
         
                @Override
                public void run(){
                
                 for(int i =0 ;i< 10 ;i++){
                 
                   try{
                         lock.lock();
                        if(state % 3 = 0){
                           system.out.print("A");
                           state++;
                           i++;
                        }
                   
                   }catch{
                     e.printTrace();
                   }finally{
                      lock.unlock();
                   
                   }
                 
                 }
                
                
                }
                
         
         }
         
         static class ThreadB extends Thread{
         
               @Override
               public void run(){
               
                  for(int i=0;i<10;i++){
                  
                       try{
                           lock.lock();
                         if(state % 3 = 1){
                         
                      
                          System.out.print("C");
                          state++;
                          i++
                           
                         
                         }
                       
                       }finally{
                       
                         lock.unlock();
                       }
                  
                  }
               
               }
         
         }
         
         static class ThreadC extend Thread{
         
                 @Override
                 public void run(){
                 
                      for(int i = 0 ; i<10 ; i++){
                      
                           try{
                               lock.lock();
                               if( state % 3 == 3 ){
                               
                                 state++;
                                 i++;
                               }
                                 
                           
                           }finally{
                           
                             lock.unlock();
                           }
                      }
                 
                 }
                 
         
         }


}
```



##### 10.28 二叉搜索树的第k大节点

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/

```
public class Solution {

    private static List<Integer> arr=new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        //中序遍历,正序赋值数组
        inOrder(root);
        //寻找第k大的数，输出
        return arr.get(arr.size()-k);
    }
    //中序遍历
    private static void inOrder(TreeNode root){
        if(root==null)
            return;
        inOrder(root.left);
        arr.add(root.val);
        inOrder(root.right);

    }
}

```



##### 10.29 合并二叉树



```

```



##### 10.30  [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)



```

```



##### 10.31 [最小面积矩形](https://leetcode-cn.com/problems/minimum-area-rectangle/)

##### 10.32 顺时针打印矩阵

https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/jian-zhi-offer-29-shun-shi-zhen-da-yin-j-7049/

```
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return new int[0];
        int n = matrix.length, m = matrix[0].length;
        int top = 0, bottom = n - 1;
        int left = 0, right = m - 1;
        int[] res = new int[n * m];
        int index = 0;
        while(true){
            // 左 -> 右
            for(int i = left; i <= right; i++){
                res[index++] = matrix[top][i];
            }
            top++;
            if(top > bottom) break;

            // 上 -> 下
            for(int i = top; i <= bottom; i++){
                res[index++] = matrix[i][right];
            }
            right--;
            if(left > right) break;

            // 右 -> 左
            for(int i = right; i >= left; i--){
                res[index++] = matrix[bottom][i];
            }
            bottom--;
            if(top > bottom) break;

            // 下 -> 上
            for(int i = bottom; i >= top; i--){
                res[index++] = matrix[i][left];
            }
            left++;
            if(left > right) break;
        }
        return res;
    }
}

作者：edelweisskoko
链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/jian-zhi-offer-29-shun-shi-zhen-da-yin-j-7049/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.33 旋转矩阵

```
先上下交换，在对角线交换
```

![leet0048.png](https://pic.leetcode-cn.com/1615651665-WFwYuH-leet0048.png)

https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/shu-ju-jie-gou-he-suan-fa-liang-chong-sh-vkrf/

```
    public void rotate(int[][] matrix) {
        int length = matrix.length;
        //先上下交换
        for (int i = 0; i < length / 2; i++) {
            int temp[] = matrix[i];
            matrix[i] = matrix[length - i - 1];
            matrix[length - i - 1] = temp;
        }
        //在按照对角线交换
        for (int i = 0; i < length; ++i) {
            for (int j = i + 1; j < length; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }

```

##### 10.34 [二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/

```
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int i = matrix.length - 1, j = 0;
        while(i >= 0 && j < matrix[0].length)
        {
            if(matrix[i][j] > target) i--;
            else if(matrix[i][j] < target) j++;
            else return true;
        }
        return false;
    }
}

```

##### 10.35 [ 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/

##### 10.36

##### 10.37

##### 10.38

##### 10.39

10.40

10.41

10.42

10.43

10.44

10.45

10.46

10.47

##### 10.48  手撕阻塞队列

```

```



##### 10.49 手撕线程死锁



https://blog.csdn.net/qq_38215042/article/details/87859890

```
public class Solution{

   Object t1 = new Object();
   Object t2 = new Object();
   
   new Thread (new Runnable(){
       
       @Override
       public void run(){
       
         String name = Thread,currentThread().getName();
         synchronized(t1){
          System.out.print("当前线程" + name);
          try{
          
             Thread.sleep(100);
          }catch( InterruptedException e)
           
           e.printStackTrace();
         }
         
         synchronized(t2){
         
            System.out.print("ddddd");
         }
         
       
       }
   
   },"线程A").start();
   
   
   new Thread(new Runnable(){
       @Override
       public void run(){
       
          String name = Thread.currentThread().getName();
          synchronized(t2){
          
            System,out.print("当前线程" + name);
            
            try{
            
              Thread.sleep(100);
            
            }catch( InterruptedException e){
            
              e.printStackTrace();
            }
            
            synchronized(t1){
            
               System.out.print("dddddd");
            }
            
          }
       
       }
   
   
   },"线程B").start();
   
}
```



##### 10.50 ThreadLocal

```
public class LoginInfoThreadLocal{

   private static final ThreadLocal<LoginInfo> local = new ThreadLocal<LoginInfo>();
   
   
   public static void set(LoginInfo bean){
   
      local.set(bean);
   }
   
   public static LoginInfo get(){
   
      local.get();
   }

}
```



#### 11. JVM

##### 11.1  JVM内存模型



```
程序计数器  ， 记录CPU指令，私有
java虚拟机栈，私有
本地虚拟机栈，私有
堆内存
方法区

```

##### 11.2 编译原理



```
1. 词法分析 ，token流

2. 语法分析，

3. 语义分析；

4. 字节码生成，
```



##### 11.3 类加载过程



```
1. 加载

2. 链接：
   
   验证，语法是否符合JVM规范
   准备，给静态变量赋值，int = 0
   解释, 间接引用转为直接引用
   
3. 初始化

4. 卸载
```



##### 11.4 类加载的顺序



```
1. 父类静态方法
2. 子类静态方法
3. 父类普通方法
4. 父类构造函数
5. 子类普通方法
6. 子类构造函数
```

##### 11.5 双亲委派机制

https://www.jianshu.com/p/9b2d43c9a09a

https://www.cnblogs.com/aspirant/p/8991830.html

```
1. 启动类加载器  Bootstrap ClassLoader ：

启动类加载器,负责加载java基础类，对应的文件是%JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等

2. 拓展类加载器  Extension ClassLoader：

对应的文件是 %JRE_HOME/lib/ext 目录下的jar和class等

3. 应用类加载器  App ClassLoader：

对应的文件是应用程序classpath目录下的所有jar和class等


4. 自定义加载类

加载一个类的时候，先用父类去加载，如果父类加载没有，再给子类加载
```



**自定义一个类加载器**

https://blog.csdn.net/huazai30000/article/details/85296671

```
public class MyClassLoader extends ClassLoader {
    //指定路径
    private String path ;
 
 
    public MyClassLoader(String classPath){
        path=classPath;
    }
 
    /**
     * 重写findClass方法
     * @param name 是我们这个类的全路径
     * @return
     * @throws ClassNotFoundException
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class log = null;
        // 获取该class文件字节码数组
        byte[] classData = getData();
 
        if (classData != null) {
            // 将class的字节码数组转换成Class类的实例
            log = defineClass(name, classData, 0, classData.length);
        }
        return log;
    }
 
    /**
     * 将class文件转化为字节码数组
     * @return
     */
    private byte[] getData() {
 
        File file = new File(path);
        if (file.exists()){
            FileInputStream in = null;
            ByteArrayOutputStream out = null;
            try {
                in = new FileInputStream(file);
                out = new ByteArrayOutputStream();
 
                byte[] buffer = new byte[1024];
                int size = 0;
                while ((size = in.read(buffer)) != -1) {
                    out.write(buffer, 0, size);
                }
 
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    in.close();
                } catch (IOException e) {
 
                    e.printStackTrace();
                }
            }
            return out.toByteArray();
        }else{
            return null;
        }
 
 
    }
}
```



**打破双亲委派机制**

https://www.jianshu.com/p/9b2d43c9a09a

https://cloud.tencent.com/developer/article/1706851

https://www.cnblogs.com/cl-rr/p/9081817.html

```
1. JDBC，通过使用线程上下午类加载器打破

2. Tomacat , 每一个应用都会生成 webAppClassLoader
```



##### 11.6  垃圾回收算法

https://blog.csdn.net/weixin_43213517/article/details/89853530



| 算法     | 优点         | 缺点     |
| :------- | ------------ | -------- |
| 标记清除 |              | 产生碎片 |
| 标记整理 | 不会产生碎片 |          |
| 复制算法 |              |          |
| 分代回收 |              |          |



##### 11.7 垃圾回收器



```
串行
series
seriesOld

并行
parNew
pallre

cms

G1
```



##### 11.8  JVM调优

```

```





##### 11.9  老年代担保机制

https://blog.csdn.net/weixin_38106322/article/details/108893760

```
当新生代被分配了大对象(该对象大小可以通过参数设置)，或者经过Minor GC后，存活下来的对象，Survivor区放不下，那么这些对象都会被分配到老年代。

老年代想担保就能担保？
老年代空间也是有限的，既然不是无限大，那么老年代在担保前也得自己掂量下，自己是不是吃的下那些要分配给自己的对象。

老年代想要担保需要遵守什么规则？
在执行任何一次Minor GC前，JVM都会检查一下老年代的的可用内存空间，然后和新生代中的所有对象的大小总和做个比较，如果大于新生代中的所有对象的大小总和，那么就可以保证Minor GC后，即使新生代中所有的对象都存活下来，Survivor区放不下，老年代也是能够完全分配下这些对象的。如果老年代的的可用内存空间是小于新生代中的所有对象的大小总和的，那么就要继续走第二步的判断。
第二步判断，要看看是否设置了“-XX:-HandlePromotionFailure”参数，该参数的作用在于会多加一步判断规则：判断老年代的的可用内存空间是否大于之前每一次Minor GC后进入老年代的对象的平均大小。如果不加这个参数或者这个参数判断失败，同时老年代的的可用内存空间小于新生代中的所有对象的大小总和，就会直接进行Full GC，尽量先腾出一些老年代空间来，然后再触发Minor GC，尽最大努力防止出现OOM。如果“-XX:-HandlePromotionFailure”参数判断是成功的，那么就走第三步。
第三步就可以试着进行Minor GC了，毕竟该做的判断做了和该满足的条件都有了，此时Minor GC后，如果存活的对象大小小于Survivor区的大小，那么存活的对象直接进入Survivor区。如果存活的对象大小大于Survivor区的大小，却小于老年代大小，那么存活的对象直接进入老年代。最极端的情况就是存活的对象大小大于Survivor区的大小，同时也大于老年代大小，那么此时机会触发一次Full GC，对老年代和新生代统一做一次垃圾回收，腾出空间，方便让Minor GC后存活的对象可以进入老年代。最差的情况就是即使经过了Full GC，老年代空间也还是不够，那么就会爆出OOM了。
————————————————

```



```
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlerPromotionFailure设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，将尝试着进行一次Monitor GC，尽管这次GC是有风险的。如果小于，或者HandlerPromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC了。

上述所说的冒险到底是冒的什么险呢？

前面提到过，新生代使用复制收集算法，但是为了内存利用率。只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况是内存回收之后，新生代中所有的对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现HandlerPromotionFailure失败，那就只好在失败后重新发起一次FULL GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是将HandlerPromotionFailure开关打开，避免Full GC过于频繁。
```



##### 11.10

##### 11.11

##### 11.12

##### 11.13

##### 11.14

##### 11.15  算法稳定性

https://www.cnblogs.com/lqminn/p/3642027.html

https://www.cnblogs.com/Leophen/p/11397731.html

http://www.javashuo.com/article/p-cqlytcrs-go.html

https://www.jianshu.com/p/a5b5b5c4ee0f



#### 12 Redis

##### 12.1 常见的数据结构

###### String 

```
底层结构，SDS ，动态字符串
```

Hash

```
渐进式哈希
```



###### set

```

```



###### sortedSet

```

```



###### List

```

```



###### 跳跃表



###### 布隆过滤





##### 12.2  常用命令



```

```

##### 12.3 RDB和AOF

```
重写的过程
```



##### 12.4 redis缓存和mysql数据库数据一致性如何保证



```
1. 只删除缓存不更新缓存

2. 
```

##### 12.5  集群模式



```
1. 主从模式
2. 哨兵模式
3. 集群模式
```

##### 12.6  redis 3 种集群方案

https://blog.csdn.net/QQ1006207580/article/details/103243281

https://www.cnblogs.com/pingyeaa/p/11294773.html

https://www.cnblogs.com/kaleidoscope/p/9630316.html

https://www.cnblogs.com/phyger/p/14277330.html

##### 12.7

12.8

12.9

12.10

12.11

#### 13. Es

##### 13.1  为什么那么快

##### 13.2  节点类型

##### 13.3   写的过程

##### 13.4  读的过程

##### 13.5

13.6

13.7

13.8

13.9



#### 14 kafka

##### 14.1 基本概念

```
1. broker

2. Topic

3. product

4. consume

5. consume group

6. p

7. ISR

8. OSR


```

##### 14.2  为啥那么快

```
1. 纯内存操作
2. 顺序寻址
3. 批量处理
4. 
```





##### 14.3 如何保证消息不丢失

##### 14.4 如何保证消息的顺序性

##### 14.5 如何

14.6

14.7

14.8

14.9

#### 15. 设计

https://www.cnblogs.com/xiaonian8/p/14111463.html

https://blog.csdn.net/linuxguitu/article/details/111676210

#### 16. linux

##### 16.1

16.2

16.3

16.4

16.5

16.6

16.7

16.8

16.9

