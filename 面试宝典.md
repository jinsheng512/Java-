#### 1. 计算机系统

https://blog.csdn.net/FlyingFish868/article/details/118666884

##### 1.1  lvs四层转发和nginx七层转发的区别？

https://www.cnblogs.com/guixia621/p/6426765.html

##### 1.2 进程间的通信方式有哪些

```
管道（匿名和非匿名）
信号量
socker
消息队列
共享内存
```

##### 1.3 负载均衡算法

```
1、轮询法

　　将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

2、随机法

     通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，

其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。

3、源地址哈希法

     源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。

4、加权轮询法

　　不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

5、加权随机法

     与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。

6、最小连接数法

     最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前

积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。


```

##### 1.4 虚拟内存

https://blog.csdn.net/qq_34116958/article/details/108399579

1.5

1.6

1.7

1.8

1.9

1.10

1.11

1.12

1.13

1.14

1.15

1.16

1.17

1.18



#### 2. 计算机网络

##### 2.1  七层协议合四层协议

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQUkM2ib9WWjiabWHbbF0B7Sq5B0RAMJwaTicopuxPlRia1x3uTEbBYD1SD4nLQM14EOibHJQV6pTjZUqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQUkM2ib9WWjiabWHbbF0B7SqiaAu3Unibiao8IWH1xIowmLQkSZmPjl3lXMznXicZmz98bbvZQFwnjpicDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





###### 常见面试题

**三次握手**的过程

![图片](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD58Npf1AOxttKsHPFl4aOQ54Znzk6P3mic47cYsh2RLgQMibV4I8iaKbZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**为什么要三次握手**

```

1. 保证双方发送接收功能都正常
2. 握手的重点就是同步初始序列号
```

**SYN 超时了怎么处理？**

```
也就是 client 发送 SYN 至 server 然后就挂了，此时 server 发送 SYN+ACK 就一直得不到回复，怎么办？
超时重传

在 Linux 中就是默认重试 5 次，并且就是阶梯性的重试，间隔就是1s、2s、4s、8s、16s，再第五次发出之后还得等 32s 才能知道这次重试的结果，所以说总共等63s 才能断开连接。
```

**SYN Flood 攻击**

```
你看到没 SYN 超时需要耗费服务端 63s 的时间断开连接，也就说 63s 内服务端需要保持这个资源，所以不法分子就可以构造出大量的 client 向 server 发 SYN 但就是不回 server。

解决方案：

1. tcp_syncookies

2. 或者调整 tcp_synack_retries 减少重试的次数，设置 tcp_max_syn_backlog 增加 SYN 队列数，设置 tcp_abort_on_overflow SYN 队列满了直接拒绝连接。
```

**四次挥手**的过程

![图片](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDfa4qx2k7PGicQrGqVPIbqNbIxmbzEicT8F1mtgFbGfmxjGWlricibfgy1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



**为什么要四次握手**

```
主动关闭方的状态是 FIN_WAIT_1 到 FIN_WAIT_2 然后再到 TIME_WAIT，而被动关闭方是 CLOSE_WAIT 到 LAST_ACK。

确保双方都关闭了，四次挥手是因为 TCP 是全双工协议，因此双方都得说拜拜。

那么假设 client 发送 FIN 给 server 的时候 server 也没数据给 client，那么 server 就可以将 ACK 和它的 FIN 一起发给client ，然后等待 client 的 ACK，这样不就三次挥手了？

```

**为什么要有TimeWait**

```
1. 服务器没有接收到 ack，可以重传fin

2. 为了保证最后一个ACK正常的丢失，因为不确认对方是否收到，需要等1个MSL，至于另一个MSL，能找到比较信服的解释就是被动关闭的一方在收到ACK的那一刻之前重发了FIN，为了保证这个FIN正常丢失，需要再等1个MSL
```

**TCP 和 UDP区别**

```
1. 可靠和不可靠
2. 传播速度

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
```

**TCP参数**

```
tcp_syncookies ， SYN Flood 攻击

tcp_syn_retries, 第一次握手

tcp_synack_retries， 第二次握手

tcp_tw_reuse ， 重用链接
```



**TCP 是如何保证可靠性的**

https://mp.weixin.qq.com/s/HjOUsKn8eLfDogbBX3hPnA

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgTfasBzdn2sIB39aFcqL22zhAa7v9d9vR1oZF4mibLUKouDEfKjYoZww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
1. 确认序列号
2. 校验和
3. 重传机制：

   快速重传
   超时重传

4. 拥塞控制：

   慢启动
   拥塞避免
   拥塞发生
   快速恢复
   

5. 流量控制：

   滑动窗口
   
   
6. 三次握手和四次挥手
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgDicBugvroe9EtiaFU38hk4JuVfDciauVPfecBNp8TPI1zkoqbibePA4dlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeuicRMlA8rKvl5AVLibhibDhgR3w50EdpWF95ZM6QPpELCF3P1niazia8nBrSQUvX7e7F7LXMiaXR3iayUA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**TCP超时重传机制是为了解决什么问题？**

```
前面我们提到 TCP 要提供可靠的传输，那么网络又是不稳定的如果传输的包对方没收到却又得保证可靠那么就必须重传。

TCP 的可靠性是靠确认号的，比如我发给你1、2、3、4这4个包，你告诉我你现在要 5 那说明前面四个包你都收到了，就是这么回事儿。

不过这里要注意，SeqNum 和 ACK 都是以字节数为单位的，也就是说假设你收到了1、2、4 但是 3 没有收到你不能 ACK 5，如果你回了 5 那么发送方就以为你5之前的都收到了。

所以只能回复确认最大连续收到包，也就是 3。

而发送方不清楚 3、4 这两个包到底是还没到呢还是已经丢了，于是发送方需要等待，这等待的时间就比较讲究了。

如果太心急可能 ACK 已经在路上了，你这重传就是浪费资源了，如果太散漫，那么接收方急死了，这死鬼怎么还不发包来，我等的花儿都谢了。

所以这个等待超时重传的时间很关键，怎么搞？聪明的小伙伴可能一下就想到了，你估摸着正常来回一趟时间是多少不就好了，我就等这么长。

这就来回一趟的时间就叫 RTT，即 Round Trip Time，然后根据这个时间制定超时重传的时间 RTO，即 Retransmission Timeout。

不过这里大概只好了 RTO 要参考下 RTT ，但是具体要怎么算？首先肯定是采样，然后一波加权平均得到 RTO。
```



**TimeWait 过多解决办法**

```
如果服务器出了异常，百分之八九十都是下面两种情况：

1.服务器保持了大量TIME_WAIT状态

2.服务器保持了大量CLOSE_WAIT状态

因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理了，接着应用程序可能返回大量Too Many Open Files异常。

先来说一说长连接和短连接，在HTTP1.1协议中，有个 Connection 头，Connection有两个值，close和keep-alive，这个头就相当于客户端告诉服务端，服务端你执行完成请求之后，是关闭连接还是保持连接。如果服务器使用的短连接，那么每次客户端请求后，服务器都会主动发送FIN关闭连接。最后进入time_wait状态。可想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态。让服务器能够快速回收和重用那些TIME_WAIT的资源，可以修改内核参数。

修改/etc/sysctl.conf如下：

#对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间

net.ipv4.tcp_syn_retries=2

#net.ipv4.tcp_synack_retries=2

#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒

net.ipv4.tcp_keepalive_time=1200

net.ipv4.tcp_orphan_retries=3

#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间

net.ipv4.tcp_fin_timeout=30

#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。

net.ipv4.tcp_max_syn_backlog = 4096

#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭

net.ipv4.tcp_syncookies = 1

#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭

net.ipv4.tcp_tw_reuse = 1

#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭

net.ipv4.tcp_tw_recycle = 1

##减少超时前的探测次数

net.ipv4.tcp_keepalive_probes=5

##优化网络设备接收队列

net.core.netdev_max_backlog=3000

修改完之后执行/sbin/sysctl -p让参数生效。


```

**closeWait过多解决办法**



```
如果一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出FIN信号，一般原因都是TCP连接没有调用关闭方法。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行，一定程度上，可以使用TCP的KeepAlive功能，让操作系统替我们自动清理掉CLOSE_WAIT连接。

但是实际上，还是主要是因为我们的程序代码有问题

```



**TCP保活机制**

```
定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个「探测报文」，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制

tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；

tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。
```

**网络诊断工具**

tcpdump

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZctmf3ObkESj41ayTbgy9q4QJeG04D7HqJAtc1eXjZ6aA6iabfibibezjAV15yyf9jPcJLSM9JLQgwzA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
命令行：

tcpdump -i eth icmp and host 192.168.66.44 -nn
```



http**发展史**

```
1.0 ， 短连接
1.1 ， 长连接，摘要算法加密，(MD5，sha1),管道技术，并行
2.0 ， 头部压缩，IO多路复用epoll
```

https **工作原理**

```
是基于http上添加的一个安全传输层
1，客户端https发起请求,服务端返回证书和秘钥
2，客户端验证证书是否正确，不正确就提示
3，客户端生产对称性加密密码，并用服务端的秘钥加密
4，服务端拿到客户端传过来的数据，并用其私钥进行解密，便可进行通信


证书预置和申请
1：客户端浏览器会预置根证书， 里面包含CA公钥
2：服务器去CA申请一个证书
3： CA用自己的签名去签一个证书，指纹信息保存在证书的数字摘要里面， 然后发送给服务器

一次访问流程（简化）
1： 客户端 sayHello
2： 服务器返回证书
3-1： 客户端验证证书内容有效性（过期时间， 域名是否相同等）
3-2： 验证证书的有效性 （是否被串改）， 通过本地根证书的CA公钥解密数字摘要，看是否匹配。
3-3：如果数字签名验证通过， 就可以使用服务器证书里面提供的公钥进行下一步通信。
```

https**客户端是如何验证证书**

```
客户端会向CA确认证书的有效性。 浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：

验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证； 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；

判断证书是否被篡改。需要与 CA 服务器进行校验；

判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率 

以上任意一步都满足的情况下浏览器才认为证书是合法的。
```

http**常见请求头和响应头**

```
一、常用的http请求头

1.Accept

Accept: text/html  浏览器可以接受服务器回发的类型为 text/html。

Accept: */*   代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。

2.Accept-Encoding

Accept-Encoding: gzip, deflate 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。

3.Accept-Language

Accept-Language:zh-CN,zh;q=0.9  浏览器申明自己接收的语言。

4.Connection

Connection: keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

 Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

5.Host（发送请求时，该报头域是必需的）

Host:www.baidu.com 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。

6.Referer

Referer:https://www.baidu.com/?start=1当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

7.User-Agent

User-Agent:Mozilla/...，告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

8.Cache-Control

Cache-Control:private 默认为private  响应只能够作为私有的缓存，不能再用户间共享

Cache-Control:public 响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.

Cache-Control:must-revalidate  响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。

Cache-Control:no-cache  响应不会被缓存,而是实时向服务器端请求资源。

Cache-Control:max-age=10 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。

Cache-Control:no-store 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

9.Cookie

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

10.Range（用于断点续传）

Range:bytes=0-5 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

二、常用的http响应头

1.Cache-Control（对应请求中的Cache-Control）

Cache-Control:private 默认为private 响应只能够作为私有的缓存，不能再用户间共享

Cache-Control:public 浏览器和缓存服务器都可以缓存页面信息。

Cache-Control:must-revalidate 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。

Cache-Control:no-cache 浏览器和缓存服务器都不应该缓存页面信息。

Cache-Control:max-age=10  是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。

Cache-Control:no-store 请求和响应的信息都不应该被存储在对方的磁盘系统中。

2.Content-Type

Content-Type：text/html;charset=UTF-8 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

3.Content-Encoding

Content-Encoding:gzip 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

4.Date

Date: Tue, 03 Apr 2020 03:52:28 GMT 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

5.Server

Server：Tengine/1.4.6  这个是服务器和相对应的版本，只是告诉客户端服务器信息。

6.Transfer-Encoding

Transfer-Encoding：chunked 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

7.Expires

Expires:Sun, 1 Jan 1994 01:00:00 GMT 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

8.Last-Modified

Last-Modified: Dec, 26 Dec 2019 17:30:00 GMT 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

9.Connection

Connection：keep-alive 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

10.Etag

ETag: "637060cd8c284d8af7ad3082f209582d" 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

11.Refresh

Refresh: 5; url=http://baidu.com  用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。

12.Access-Control-Allow-Origin 

Access-Control-Allow-Origin: *   *号代表所有网站可以跨域资源共享，如果当前字段为*那么Access-Control-Allow-Credentials就不能为true

Access-Control-Allow-Origin: www.baidu.com 指定哪些网站可以跨域资源共享

13.Access-Control-Allow-Methods

Access-Control-Allow-Methods：GET,POST,PUT,DELETE  允许哪些方法来访问

14.Access-Control-Allow-Credentials

Access-Control-Allow-Credentials: true  是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true

15.Content-Range

Content-Range: bytes 0-5/7877 指定整个实体中的一部分的插入位置，它也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。 作者：SKYLINE公寓11 https://www.bilibili.com/read/cv6259072/ 出处：bilibili
```

**常见的状态码**

https://www.jianshu.com/p/369db1ba04ea

```
2**开头 （请求成功）表示成功处理了请求的状态代码。

200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201 （已创建） 请求成功并且服务器创建了新的资源。
202 （已接受） 服务器已接受请求，但尚未处理。
203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206 （部分内容） 服务器成功处理了部分 GET 请求。

3** 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4**开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
400 （错误请求） 服务器不理解请求的语法。
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403 （禁止） 服务器拒绝请求。
404 （未找到） 服务器找不到请求的网页。
405 （方法禁用） 禁用请求中指定的方法。
406 （不接受） 无法使用请求的内容特性响应请求的网页。
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408 （请求超时） 服务器等候请求时发生超时。
409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

5**开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

500 （服务器内部错误） 服务器遇到错误，无法完成请求。
501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。


```



**常见加密算法**

```
对称加密： DES,AES
非对称加密： RSA,ECC
摘要算法： MD5，SHA
```



##### 2.2 DNS

###### DNS劫持是什么，怎么解决

```
DNS劫持是黑客入侵网站的常见手段。这种攻击会返回虚假信息，甚至无法访问网站。DNS劫持是比如你进入360的网站，但它是从百度的页面出来的。这意味着你的DNS被劫持了。

专业的DNS劫持，称为域名系统，是指在被劫持的网络范围内拦截域名解析请求，分析请求的域名，发布超出审查范围的请求，否则返回虚假IP地址或不做任何事情都会使请求失去响应，其效果是特定网络无法响应或返回假地址。 

DNS解析原则以下示例，正常情况下：用户在浏览器中输入帝恩思的域名，然后计算机向DNS服务器发送请求，询问帝恩思该域名的IP地址是什么？查询完成后，服务器返回帝恩思域名对应的IP地址：1.1.1.1，计算机访问该IP地址 作者：haizi0012 https://www.bilibili.com/read/cv8896654/ 出处：bilibili
```

###### DNS**的结构**

- 根 DNS 服务器
- 顶级域 DNS 服务器（com）
- 权威 DNS 服务器（server.com）

![图片](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdCwxNydn5YuT0s7aLuqWCvN6F6eZ2vAU04o8gh1mJ6l7ovc7wsCvTVMvCFHyHqfsRUKtWYnblsCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



###### 工作原理

```
客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。

本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。

根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”

本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com  的 IP 地址吗？”

顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。

本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。

权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。

本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。
```



##### 2.3 CDN

**工具varnish**

https://blog.csdn.net/xiangzhihong8/article/details/83147542

![在这里插入图片描述](https://img-blog.csdn.net/20181018152139324)

2.4

2.5

2.6

2.7

2.8

2.9

2.10

2.11

2.12

2.13

2.14

2.15

2.16



#### 3. java基础

##### 3.1   break 和 continue 的区别

```

   break， 跳出整个循环
   continue， 跳出当前某一个循环
```



##### 3.2  && 和 || 的使用

##### 3.3 String ,StringBuilder ,StringBuffer的区别

##### 3.4  JDK 各版本 新属性

https://www.cnblogs.com/ulong/p/10212823.html

```
1.7 ：

1.8 ：
接口有默认实现方法了，只需要使用 default关键字即可
Lambda 表达式
Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用

Optional 接口:

Optional<String> optional = Optional.of("bam");
optional.isPresent();           // true
optional.get();                 // "bam"
optional.orElse("fallback");    // "bam"

optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"

Stream 流:
并行Streams
Count 计数
Match 匹配
Map 映射
Sort 排序
Filter 过滤





DateTimeFormatter是不可变的，所以它是线程安全的
https://blog.csdn.net/dxhtostage/article/details/103905994




```

##### 3.5  JDK 1.7  和1.8版本 时间格式化的区别

https://blog.csdn.net/dxhtostage/article/details/103905994

```
SimpleDateFormat是线程不安全的，在并发环境下使用SimpleDateFormat；
DateTimeFormatter是线程安全的，jdk8自带（ java.time.format.DateTimeFormatter）；
Joda time里的DateTimeFormat也是线程安全。
```



##### 3.6 抽象类和接口的区别

##### 3.7 快速失败和安全失败

##### 3.8 i++ 和 ++i 的区别

##### 3.9 包装类Integer.valueof(""),使用了缓存

##### 3.10 类的封装性

```
private ， 同一类中可见
default,   同一包中的类
protect,   不同包中的子类
public ，所有
```

##### 3.11  类的多态性：

##### 3.12 创建对象4种方式

```
  new
  clone
  反序列化
  反射机制
```



##### 3.13 final， finally，finalize的区别

##### 3.14 异常

```
1. 受检异常，IDEA 爆红，
2. 非受检异常
```

##### 3.15 匿名内部类

https://www.cnblogs.com/chenssy/p/3390871.html

```
     1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。

     2、匿名内部类中是不能定义构造函数的。

     3、匿名内部类中不能存在任何的静态成员变量和静态方法。

      4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。

     5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
     
     
      我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。
```

3.16

3.17

3.18

3.19

3.20





#### 4. java高级

##### 4.1 集合

######  解决冲突的方法：

https://www.jianshu.com/p/a343dae4a818

```
 链地址法
 再哈希法
 建立公共溢出区
 开放地址法
```



###### HashMap



https://www.bbsmax.com/A/qVde0aBp5P/

```
1.7 
数组+链表 
put 和 get 的过程：
首先判断集合是否为空，空的话进行初始化，否则根据传进来的key，进行hash，按位异或 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);高低位都进行计算，减少哈希冲突，
如果key为null，放到第一个key位置
如果集合不存在，直接插入
如果集合存在，

安全性，头插法，造成循环，CPU 100%

1.8 数组 + 链表 + 红黑树
 链表大于8的时候转为红黑树
 
 安全性，尾插法，数据覆盖导致不安全
 



```

###### currentHashMap



```
1.7 
sedment + ReetrantLock


```



###### get过程

###### put过程



###### size计算

```
众所周知，concurrenthashmap有很多歌segments，首先遍历segments将每个segment的count加起来作为整个concurrenthashMap的size。如果没有并发的情况下这自然就可以了，但这是多线程的，如果前脚统计完后脚有变化了，这就不准确了，源码中引入了，modCount和两次比较来实现size的确认。具体过程是：

1.进行第一遍遍历segments数组，将每个segemnt的count加起来作为总数，期间把每个segment的modCount加起来sum作为结果是否被修改的判断依据。
这里需要提一下modCount，这个是当segment有任何操作都会进行一次增量操作，代表的是对Segment中元素的数量造成影响的操作的次数，这个值只增不减！！！！只增不减很重要，这样就不会出现一个segment+1，导致modcount+1,而另一个segment-1，即modcount-1 ,从而在统计所有的时候modcount没有变化。

2.size操作就是遍历了两次所有的Segments，每次记录Segment的modCount值，然后将两次的modCount进行比较，如果相同，则表示期间没有发生过写入操作，就将原先遍历的结果返回，如果不相同，则把这个过程再重复做一次，如果再不相同，则就需要将所有的Segment都锁住，然后一个一个遍历了。

3.如果经判断发现两次统计出的modCount并不一致，那就如上所说，要重新启用全部segment加锁的方式来进行count的获取和统计了，这样在此期间每个segement都被锁住，无法进行其他操作，统计出的count自然很准确。

而之所以之所以要先不加锁进行判断，道理很明显，就是不希望因为size操作获取这么多锁，因为获取锁不光占用资源，也会影响其他线程对ConcurrentHash的使用，影响并发情况下程序执行的效率。使用锁要谨慎！

```



##### 4.2 反射

###### 获取类对象

```
Class c1=User.class;

Class c2=u.getClass();

Class c3=Class.forName("com.forezp.User");
```

###### 获取类实例

```
User user=(User)c1.newInstance();
```



###### 获取类方法

```
getMethod()所有的 public方法，包括父类继承的 public

 getDeclaredMethods()获取该类所有的方法，包括private ,但不包括继承的方法。
```



###### 获取类属性

###### 获取类构造函数

```

public static void printConstructInfo(Object o){
        Class c=o.getClass();

        Constructor[] constructors=c.getDeclaredConstructors();
        for (Constructor con:constructors){
            System.out.print(con.getName()+"(");

            Class[] typeParas=con.getParameterTypes();
            for (Class class1:typeParas){
                System.out.print(class1.getName()+" ,");
            }
            System.out.println(")");
        }
    }


```

###### 实战

```
 public static void main(String[] args) {
        A a=new A();
        Class c=a.getClass();
        try {
            Method method=c.getMethod("add",new Class[]{int.class,int.class});
            //也可以 Method method=c.getMethod("add",int.class,int.class);
            //方法的反射操作
            method.invoke(a,10,10);
        }catch (Exception e){
            e.printStackTrace();
        }
    }

```

###### 如何往一个List<int>里面插入一个String？

```
抛开实用性，我们只是简单的去探讨一下这个问题。
List<String>指定了添加到List的对象必须为String类型，范型约束的产生在编译阶段，那么我们是否能够绕过编译，在运行阶段添加一个int类型的数据呢，答案是肯定的。

        List<String> list1 = new ArrayList<>();
        list1.add("test1");
        // 添加int类型数据报错
        // list1.add(20);

        Class class2 = list1.getClass();
        try {
            Method method1 = class2.getMethod("add", Object.class);
            // 通过反射机制操作list1
            method1.invoke(list1, 20);

            // 输出结果[test1, 20]
            System.out.println(list1);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

作者：i左撇子
链接：https://www.jianshu.com/p/3fde9cdfb432
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 4.3 序列化

###### 定义

```
序列化： 将对象写入到IO流中
反序列化： 将IO流中恢复对象

对象的类名、实例变量（包括基本类型，数组，对其他对象的引用）都会被序列化
方法、类变量、transient实例变量都不会被序列化。
```

###### 使用场景

```
远程过程调用（RPC），所有在网络传输的对象必须是可序列化的
```

###### 序列化方式

```
实现Serializable接口

实现Externalizable接口，自定义
```



###### 序列化怎么保证升级前后的兼容性

```
private static final long serialVersionUID
```

###### 序列化的类型

```
JDK自带的，效率低

Google Protobuf

FaceBook
```



##### 4.4

##### 4.5

##### 4.6

##### 4.7









#### 5. 多线程

##### 5.1 线程的生命周期

```
1. 初始
2. 就绪状态
3. 运行状态
4. 中断状态
5. 中止状态
```



##### 5.2  如何优化线程池



```
1. 设置其最大线程，最小线程数，IO密集型，2CPU ，cpu密集型：CPU+1

2. 设置线程的空闲时间，keepTimeAlive

3. 抛弃队列的选择
```



##### 5.3  为什么指令重[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)能优化代码执行速度

https://blog.csdn.net/weixin_37841366/article/details/113086438

```
重排序通过减少执行指令，从而提高整体的运行速度，这就是重排序带来的优化和好处。
```



##### 5.4 线程池原理

7**个核心参数**

```
核心线程数 

最大线程数

线程空闲时间

线程空闲时间单位

工作队列

抛弃策略

线程工厂
```

**原理**



```

```

##### 5.5 死锁

https://blog.csdn.net/guaiguaihenguai/article/details/80303835

**四个必须**

```
1. 相互互斥
2. 不可剥夺条件，只能线程自己释放资源
3. 循环等待
4. 占有并且等待
```



**预防死锁**

```
打破其四个必要条件：

1. 一次性申请所有资源，简单安全，但资源利用率低
2. 该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。
3.破坏“不可抢占”条件
      当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。
      该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。
4.破坏“循环等待”条件
     可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源
这样虽然避免了循环等待，但是这种方法是比较低效的，资源的执行速度回变慢，并且可能在没有必要的情况下拒绝资源的访问，比如说，进程c想要申请资源1，如果资源1并没有被其他进程占有，此时将它分配个进程c是没有问题的，但是为了避免产生循环等待，该申请会被拒绝，这样就降低了资源的利用率
```



**防止死锁**

```
    1、如果一个进程的请求会导致死锁，则不启动该进程
    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。
避免死锁的具体实现通常利用银行家算法
```

**死锁解除**

```
如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，此时就需要对系统采取相应的措施。常用的解除死锁的方法：
1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。
2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。
    a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。
     b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。一般根据如下几个方面来决定终止哪个进程：
    进程的优先级
    进程已运行时间以及运行完成还需要的时间
    进程已占用系统资源
    进程运行完成还需要的资源
    终止进程数目
    进程是交互还是批处理

```



##### 5.6  常见关键字

###### ThreadLocal

https://baijiahao.baidu.com/s?id=1663127810801876375&wfr=spider&for=pc

https://www.freesion.com/article/5698706089/

https://www.cnblogs.com/q540973436/p/13539021.html

https://juejin.cn/post/6844903878870171662 fastThreadLocal



https://blog.csdn.net/ol950919/article/details/108106533

```
底层结构： threadLocalMap
从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值。ThreadLocalMap 解决 hash 冲突的方式采用的是线性探测法，如果发生冲突会继续寻找下一个空的位置。

ThreadLocal 在没有外部强引用时，发生 GC 时会被回收，那么 ThreadLocalMap 中保存的 key 值就变成了 null，而 Entry 又被 threadLocalMap 对象引用，threadLocalMap 对象又被 Thread 对象所引用，那么当 Thread 一直不终结的话，value 对象就会一直存在于内存中，也就导致了内存泄漏，直至 Thread 被销毁后，才会被回收。

fastThreadLocal 是 ThreadLocal 的替代品，吞吐量更快，内部实现了自动删除，不会存在内存泄露

InheritableThreadLocal

```



```
public class Test {
    public static InheritableThreadLocal threadLocal = new InheritableThreadLocal();
    public static void main(String[] args) throws Exception{
        threadLocal.set("主线程的值");
        System.out.println(threadLocal.get());
        Thread.sleep(3000);
        new Thread( ()-> {
            threadLocal.set("子线程的值");
            System.out.println(threadLocal.get());
        }).start();
        Thread.sleep(3000);
        System.out.println(threadLocal.get());
    }
}

InheritableThreadLocal关键字中子线程会继承父线程存储的数据。子线程可以修改继承的主线程的存储数据，且主线程的存储数据不受影响。

```



###### synchronize



```
底层原理：monitorenter monitorexit


对象头： Hash,分代年龄，锁标志，01,01,00,10  无锁，偏向锁，轻量级锁，重量级锁

同步代码快
同步方法 ACC_SYNCHRONIZED
同步对象
```



###### volitale

https://www.jianshu.com/p/ef8de88b1343 内存屏障

```
只能保证可见性，顺序性，不能保证原子性

　　volatile很好的保证了变量的可见性，变量经过volatile修饰后，对此变量进行写操作时，汇编指令中会有一个LOCK前缀指令，这个不需要过多了解，但是加了这个指令后，会引发两件事情：

　　将当前处理器缓存行的数据写回到系统内存
　　这个写回内存的操作会使得在其他处理器缓存了该内存地址无效什么意思呢？意思就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，这就保证了可见性。
　　
　　顺序性，是通过内存屏障来实现的

```



###### ReetrancLock





#### 6. Spring

##### 6.1 IOC

##### 6.2 AOP

```

```



##### 6.3 生命周期

```

```



##### 6.4  三级缓存

https://www.cnblogs.com/semi-sub/p/13548479.html

##### 6.5 SpringMVC



```

```



##### 6.6 Spring 拓展点

https://baijiahao.baidu.com/s?id=1679178070358092034&wfr=spider&for=pc

```
1. Bean定义时扩展
BeanDefinitionRegistryPostProcessor

2. BeanFactoryPostProcessor
在BeanFactory生成之后，通过该接口自定义修改应用程序上下文的BeanDefinition，调整上下文的BeanFactory的bean属性值。

3. 
```



##### 6.7

##### 6.8



#### 7. 中间件

7.1

7.2

7.3

7.4

7.5

7.6

7.7



#### 8. 数据库

##### 8.1 Myisam  和 Inodb的区别

##### 8.2 Inodb 的底层原理

##### 8.3 mysql 的执行过程

##### 8.4 事务

###### 事务的四个特性：

```

1. 一致性
2. 隔离性
3. 持久性
4.

```



###### 事务隔离级别

```
1. 读未提交
2. 读已提交
3. 可重复读
4. 串行化
```



###### 多版本控制MVCC

```
快照读
当前读
readview undo 日志 ，读已提交，生成新的快照，可重复读。只用第一个快照

```



##### 8.5 索引 

###### 索引类别

```
1. 聚簇索引
2. 非聚簇索引
3. 覆盖索引
4. 辅助索引
5. 组合索引
6. 

```

###### 索引原理B+树

```

```



##### 8.6 日志



##### 8.7  

8.8

8.9

8.10

8.11

8.12

8.13



#### 9.  设计模式



##### 9.1 单列模式

```
单例模式，防止反射和反序列化漏洞：

修改构造函数：
	private SingletonDemo6() {
		// 防止反射获取多个对象的漏洞
		if (null != instance) {
			throw new RuntimeException();
		}
	}

```



**懒汉模式**

```
 public class Singleton{
 
    private static volitale Singleton instance;
    
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
    
          if(instance == null){
          
              synchronized( Singleton.class){
              
                 if(instance == null){
                 
                    instance = new Singleton();
                 
                 }
              }
          
          }
               return instance;
    }
 
 }
```



**恶汉模式**

```
public class Singleton{

     private static Singleton instance = new Singleton();
     
     private Singleton(){
     
     }
     
     public static Singleton getInstance(){
     
            return instance;
     }

}
```



**静态内部类**



```
  public class Singleton{
  
    private static class SingletonHolder {
    
      private static final Singleton instance = new Singleton();
    
    }
    
    private Singleton(){
    
    }
    
    public static Singleton getInstance(){
    
        return SingletonHolder.instance;
    }
  
  }
```



**枚举**





##### 9.2 策略模式



```

```



##### 9.3 适配器模式



```

```



##### 9.4 模板模式

```

```



##### 9.5 原型模式

##### 9.6 观察者模式

##### 9.7

##### 9.8





#### 10. 算法

##### 10.1 反转链表

​    **迭代法**

```
public class Solution{

    public ListNode reverseList(ListNode head){
    
            ListNode next = null;
            ListNode pre = null;
            
            while(head != null){
            
                next = head.next;
                head.next = pre;
                pre = head;
                head = next;
            
            }
           
           return pre;
    
    }

}
```



  **递归法**

```

```



##### 10.2 链表是否有环



**快慢指针**

```
public class Solution{

     public boolean hasCycle(ListNode head){
              
              ListNode fast = head;
              ListNode slow = head
     
            while(fast null && fastxt != null){
            
                   fast = fast.next.next;
                   slow = slow.next;
                    
                    if(fast == slow){
                    
                        return true;
                    
                    }
            
            }
     
          return false;
     }

}
```



##### 10.3  二叉树前中后序遍历



```

（1）先(根)序遍历（根左右）

（2）中(根)序遍历（左根右）

（3）后(根)序遍历（左右根）


public class Solutioon{

      public void preOrder(TreeNode root , List<Integer> list){
      
          if(root != null){
          
             list.add(root.val);
             preOrder(root.left,list);
             preOrder(root.right,list);
          
          }
      
      }
      
      
      public void inOrder(TreeNode root, List<Integer> list){
      
      
      }
      
      
      public void postOrder(TreeNode root, List<Integer> list){
      
      
      }

}
```

##### 10.4 二叉树层序遍历



**队列，先进先出**

```
public class Solution{

      public List<List<Integer>> leverOrder(TreeNode root){
      
              List<List<Integer>> res = new ArrayList<List<Integer>>();
      
              LinkerList<TreeNode> queue = new LinkerList<TreeNode>();
              
              queue.add(rooot.val);
              
              while(queue.size()!=0){
              
                  List<Integer> temp = new ArrayList<Integer>();
                  
                  for(int i=0 ;i<queue.size() ;i++){
                  
                      TreeNode  t = queue.remove();
                      temp.add(t.val);
                      if(t.left != null){
                      
                         queue.add(t.left);
                      }
                  
                      if(t.right != null){
                      
                         queue.add(t.right);
                      }
                  }
                  
                  res.add(ttemp);
              
              
              }
              
              return res;
      }

}
```



```
    public ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {
        //边界条件判断
        if (root == null)
            return new ArrayList<>();
        //队列
        Queue<TreeNode> queue = new LinkedList<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        //根节点入队
        queue.add(root);
        //如果队列不为空就继续循环
        while (!queue.isEmpty()) {
            //BFS打印，levelNum表示的是每层的结点数
            int levelNum = queue.size();
            //subList存储的是每层的结点值
            ArrayList<Integer> subList = new ArrayList<>();
            for (int i = 0; i < levelNum; i++) {
                //出队
                TreeNode node = queue.poll();
                subList.add(node.val);
                //左右子节点如果不为空就加入到队列中
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
            //把每层的结点值存储在res中，
            res.add(subList);
        }
        return res;
    }
```



##### 10.5 用栈实现队列



```
  public class Solution{
  
       Stack<Integer> A = new Stack<Integer>();
       Stack<Integer> B = new Stack<Integer>();
       
       public void push(int node){
       
             A.push(node);
       
       }
       
       public int pop(){
       
           if(B.size()<= 0){
           
             while( A.size() != 0){
             
                B.push(A.pop());
             }
           }
           
           return B.pop();
       }
  
  }
```





##### 10.6  两数之和



```
  public class Solution{
  
       public int[] twoSum(int[] nums, int target){
       
       
              Map<Integer,Integer> map = new HashMap<Integer,Integer>();
              
              for(int i=0; i< nums.length-1 ;i++)
              {
                   if(map.containsKey(target-nums[i])){
                   
                      return new int[]{map.get(target-nums[i],i)};
                   
                   }else{
                   
                      map.put(nums[i],i)
                   }

              }
       
       
       }
  
  
  }
```



##### 10.7 整数反转



```
   public class Solution{
   
        pubblic int reverseInt(int x){
        
             int res = 0;
             while(x != 0){
             
                 int temp = x / 10 + res * 10;
                 
                 res = temp;
                 x /= 10;
             
             }
             
             return res;
        
        }
   
   
   }
```



##### 10.8  从尾到头打印链表

https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/xie-liao-na-yao-duo-ci-zong-jie-san-chon-exv5/

```
   public class Solution{
   
        public int[] reverseList(ListNode head){
        
         Stack<Integer> stack = new Stack<Integer>();
         
           while(head != null){
           
                 stack.push(head.val);
                 head = head.next;
           }
         
         int[] num = new int[stack.size()];
         
         for(int i = 0 ; i< num.length ;i++){
         
           num[i] = stack.pop();
         
         
         }
         
         return num;
        
        } 
   
   }
```



##### 10.9  替换空格

https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/solution/ti-huan-kong-ge-shuang-zhi-zhen-fa-by-ja-z8rz/

```
   public class Solution{
   
       public String replaceSpace(String str){
       
                 if( str == null){
                 
                    return null;
                 }
                 
                 StringBulider sb = new StringBuilder();
                 
                 for(int i = 0 ; i< str.length(); i++){
                 
                      if(String.valueOf(str.charAt(i)).equals("")){
                      
                         sb.append("%20");
                         
                      }else{
                      
                      
                         sb.append(str.charAt(i))
                      }
                      
                 
                 }
                 
                 return sb.toString();
       
       }
   
   
   }
```



##### 10.10  二分查找算法

 时间复杂度 **logn**

```
public class Solution{

      public int twoSearch(int[] nums ,int target){
      
       int left = 0;
       int right = nums.length;
       int mid = 0;
       
       while( left < right){
       
          mid = (left + right )/2;
          
          if(nums[mid] == target){
          
           while(mid != null && mums[mid] = nums[mid-1]){
          
                mid--;
                return mid;
                
          }
          }
         
          
          if(nums[mid] > target){
          
                 right = mid -1;
          }
           
          if(nums[mid] < target){
          
                 left = mid + 1;
          }
       
       }
      
      return -1;
      }

}
```



##### 10.11 合并两个排序的链表



```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        
        if(list1 == null){
            
            return list2;
        }
        
        if(list2 == null){
            
            return list1;
        }
        
        if(list1.val< list2.val){
            
            list1.next = Merge(list1.next,list2);
            return list1;
            
            
        }else{
            
            list2.next = Merge(list1,list2.next);
            return list2;
        }
        
    }
}
```



##### 10.12 跳台阶



```
   public class Solution{
   
       public int jumpFloor(int target){
       
       
            if(target == 1 ){
            
                return 1;
            }
            
            if(target == 2 ){
            
                return 2;
            }
            
            
            int a= 1;
            int b= 2;
            int temp = 0;
            
            for( int i = 3 ;i<= target ;i++){
            
               temp = a;
               a = b;
               b = temp + b;
            
            
            }
            
            
            return b;
       
       }
   
   
   }
```



##### 10.13 设计LRU

https://blog.csdn.net/weixin_43935927/article/details/108944786

https://blog.csdn.net/LazyCancerPatiens/article/details/106453953?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&spm=1001.2101.3001.4242

```
LRU(Least Recently Used)，即最近最少使用算法。常用于实现一个简单的缓存功能，就是把很久未使用的直接移除掉，只保留最近使用的。

LRU主要需要实现两个功能

添加缓存(涉及到删除缓存)
获取缓存

实现原理
一个单链表就能实现简单的LRU算法：但是链表的查找时间复杂度比较高了，是O(n)。

一个散列表+双链表实现一个O(1)复杂度的LRU算法：用散列表就可以直接定位某个缓存，时间复杂度O(1)，但是散列表插入缓存之后，就没有了顺序，所以才需要一个链表来维护这个缓存的顺序，超过缓存最大容量之后需要删除未使用的缓存。而如果单链表删除某个缓存的话，又需要先遍历这个元素（时间复杂度O(n)）才行。所以这里用双链表就可以在O(1)时间复杂度内删除这个缓存了。


package com.arithmetic.code;

import java.util.HashMap;
import java.util.Map;

public class LRUCache {

    private int cacheSize = 10; // map 长度
    private Map<String,Node> map = new HashMap<>();
    private Node head; // 头部节点
    private Node tail; // 尾部节点

    public void LRUCache(int cacheSize) {
        this.cacheSize = cacheSize;
    }

    class Node{
        String key;
        String value;
        Node pre; // 当前节点的上级引用
        Node next; // 当前节点的下级引用
        
        public Node(String key,String value){
            this.key = key;
            this.value = value;
        }
    }

    /**
     * 向缓存中添加值，head为最不常用值，tail为最新值
     * 链表头部为最不常用值，最新访问或者添加的元素置于链表尾部
     */
    public void  addCache(String key,String value){
        if(map.containsKey(key)){
            // 判断Node所在位置
            Node node = map.get(key);
            if(node.next != null){ // 说明node肯定不是在链表结尾
                if(node.pre == null){ // node位于头部
                    head = node.next;
                    // 注意：新的head节点需要将pre置为null，不可省略，否则新的头部节点会存在之前的上级引用
                    head.pre = null;
                } else { // node位于链表中间
                    node.pre.next = node.next;
                    node.next.pre = node.pre;
                }
                //此时将node 放在结尾
                tail.next = node;
                node.pre = tail;
                node.next = null;
                tail = node;
            }
        } else { // map中不存在该元素
            Node node = new Node(key,value);
            if(map.size() == cacheSize){ // map已到最大存储范围
                // 将头部节点删除，然后再尾部添加最新元素
                Node temp = head;
                head = head.next;
                // 新的head节点需要将pre置为null
                head.pre = null;
                map.remove(temp.key);
                //此时将node 放在尾部
                tail.next = node;
                node.pre = tail;
                node.next = null;
                tail = node;
            } else {
                if(map.size() == 0){
                    head = node;
                    tail = node;
                } else {
                    tail.next = node;
                    node.pre = tail;
                    // 新的head节点需要将pre置为null
                    node.next = null;
                    tail = node;
                }
            }
            map.put(key,node);
        }
    }

	// 从当前缓存中获取值
    public String getCache(String key){
        if(map.containsKey(key)){ // 现有元素包含key
            Node node = map.get(key);
            if(node.next != null){
                if(node.pre == null){ //  位于头部
                    head = node.next;
                    // 新的head节点需要将pre置为null
                    head.pre = null;
                } else {
                    node.pre.next = node.next;
                    node.next.pre = node.pre;
                }
                node.pre = tail;
                tail.next = node;
                node.next = null;
                tail = node;
            }
            return node.value;
        } else {
            return null;
        }
    }

	// 进行测试
    public static void main(String[] args) {
        LRUCache cache = new LRUCache();
        cache.addCache("key0", "value0");
        cache.addCache("key1", "value1");
        cache.addCache("key2", "value2");
        cache.addCache("key3", "value3");
        cache.addCache("key4", "value4");
        cache.addCache("key5", "value5");
        cache.addCache("key6", "value6");
        cache.addCache("key7", "value7");
        cache.addCache("key8", "value8");
        cache.addCache("key9", "value9");
        //从此处开始map已满，新添加的元素会将头部删除，自身放于链表末尾
        cache.addCache("key10", "value10");
        cache.addCache("key11", "value11");
        cache.addCache("key12", "value12");
        // debug 程序可知添加此node后 head 为key4，tail 为key13
        cache.addCache("key13", "value13");
        // debug 程序可知map中head 为key5，tail 为key4（即将自身从头部移动到尾部）
        cache.getCache("key4");
    }
}



```



```
import java.util.*;


public class Solution {
    /**
     * lru design
     * @param operators int整型二维数组 the ops
     * @param k int整型 the k
     * @return int整型一维数组
     */
    public class Node{
        private int val;
        private int key;
        private Node pre =null;
        private Node next =null;
        private Node(int key,int val){
            this.val=val;
            this.key=key;
        }
    }

    private HashMap<Integer,Node> map = new HashMap();
    private Node head = new Node(-1,-1);  //头节点
    private Node tail = new Node(-1,-1);  //尾节点
    private int k=0;

    public int[] LRU (int[][] operators, int k) {
        // write code here
        this.k = k;
        head.next = tail;
        tail.pre = head;

        int len = (int)Arrays.stream(operators).filter(x->x[0]==2).count();  //获取数组中开头为2（get操作）的元素个数        
        int res[] = new int[len];

        for(int i=0,j=0;i<operators.length;i++){
            if(operators[i][0] == 1){   //获取数组中开头为1（set操作）的元素个数
                set(operators[i][1],operators[i][2]);  //set(key,val)
            }else{   //获取数组中开头为2（get操作）的元素个数
                res[j++] = get(operators[i][1]);  //get(key)
            }
        }
        return res;
    }

    public void set(int key,int val){
        //判断是否存在key 
        Node node = null;
        if(map.containsKey(key)){   //如果已经存在key，将val更新，并删除这个节点，再将node插入到表头
            node = map.get(key);
            node.val = val;
            //删除该结点
            node.next.pre = node.pre;
            node.pre.next = node.next;
            //将node节点提到第一个
            moveToFirst(node);
        }else{  //如果不存在key，先判断是否超出空间，如果超出先在链表和map删除最后一个节点，再将节点插入到表头，并将对应的映射添加到map中
            if(map.size()==k){
                //在map中删除映射到最后一个节点的key
                int keyremove =tail.pre.key;
                map.remove(keyremove);
                //在链表中删除最后一个节点
                tail.pre.pre.next = tail;
                tail.pre = tail.pre.pre;
            }
            node = new Node(key,val);
            //在map中添加对新节点的映射
            map.put(key,node);
            //将节点插入到表头
            moveToFirst(node);

        }
    }

    public int get(int key){
        // 如果不存在key 则返回-1
        // 如果存在key，先将该key的结点删除，然后再将此节点插入到链表的表头
        if(!map.containsKey(key)){
            return -1;
        }else{
            Node node = map.get(key);
            //删除该结点
            node.next.pre = node.pre;
            node.pre.next = node.next;
            //插入到表头
            moveToFirst(node);
            return node.val;
        }
    }
    //将节点插入到表头
    public void moveToFirst(Node node){
            head.next.pre =node;
            node.next =head.next;
            node.pre =head;
            head.next=node;
    }
}
```



##### 10.14 最小K个数

https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/

```
   public class Solution{
   
        public List<Intteger> quickSort(int[] put, int k){
        
                ArrayList<Integer> res = new ArrayList<Integer>(k);
                if(k > put.length || k = 0){
                
                     return res;
                }
                
                quickSort11( put,k,0,put.length -1);
                
                return res;
        }
        
        public List<Integer> quickSort11(int[] put,int k ,int left, int right){
        
                 int start = left ;
                 int end = right;
                 
                 while(left < right){
                 
                    while(left < right && put[right] > put[start]){
                    
                      right--;
                    }
                    
                    while(left < right && put[left] < put[start]){
                    
                      left++;
                    }
                    
                    swap(put,left,right);
                 }
                 
                 swap(put ,left,start);
                 
                 if(left > K){ 
                 
                 quickSort11(put,res,k,start,left-1)
                 
                 }else if(left < K){
                 
                 quickSort11(put,res,k,left+1,end)
                 
                 }else{
                 
                    if(i = 0;i<k;m++){
                    
                       res.add(input[m]);
                    }
                 }
                 
                 
        
        }
        
       private void swap(int[] arr, int i, int j) {
        if (i == j)
            return;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
   
   }
```



```
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        quickSort(arr, 0, arr.length - 1);
        return Arrays.copyOf(arr, k);
    }
    private void quickSort(int[] arr, int l, int r) {
        // 子数组长度为 1 时终止递归
        if (l >= r) return;
        // 哨兵划分操作（以 arr[l] 作为基准数）
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr, i, j);
        }
        swap(arr, i, l);
        // 递归左（右）子数组执行哨兵划分
        quickSort(arr, l, i - 1);
        quickSort(arr, i + 1, r);
    }
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        if (k >= arr.length) return arr;
        return quickSort(arr, k, 0, arr.length - 1);
    }
    private int[] quickSort(int[] arr, int k, int l, int r) {
        int i = l, j = r;
        while (i < j) {
            while (i < j && arr[j] >= arr[l]) j--;
            while (i < j && arr[i] <= arr[l]) i++;
            swap(arr, i, j);
        }
        swap(arr, i, l);
        if (i > k) return quickSort(arr, k, l, i - 1);
        if (i < k) return quickSort(arr, k, i + 1, r);
        return Arrays.copyOf(arr, k);
    }
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.15 丑数

##### 10.16  最大公约数

##### 10.17 大数相加

https://blog.csdn.net/yang10560/article/details/86527911

https://cloud.tencent.com/developer/article/1846675

##### 10.18 旋转数组

##### 10.19 最长回文字串

##### 10.20 最大堆,求最小K个数

我们要保证堆的大小不能超过K，然后遍历数组，因为是最大堆，也就是堆顶元素是堆中最大的，如果遍历的元素小于堆顶元素，就把堆顶元素给移除，然后再把当前遍历的元素加入到堆中，最后在把堆中元素转化为数组即可

```
    public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
        ArrayList<Integer> res = new ArrayList<>(k);
        //根据题意要求，如果K>数组的长度，返回一个空的数组
        if (k > input.length || k == 0)
            return res;
        //创建最大堆
        PriorityQueue<Integer> queue = new PriorityQueue<>((num1, num2) -> num2 - num1);
        //先在堆中放数组的前k个元素
        for (int i = 0; i < k; ++i) {
            queue.offer(input[i]);
        }
        //因为是最大堆，也就是堆顶的元素是堆中最大的，遍历数组后面元素的时候，
        //如果当前元素比堆顶元素大，就把堆顶元素给移除，然后再把当前元素放到堆中，
        for (int i = k; i < input.length; ++i) {
            if (queue.peek() > input[i]) {
                queue.poll();
                queue.offer(input[i]);
            }
        }
        //最后再把堆中元素转化为数组
        for (int i = 0; i < k; ++i) {
            res.add(queue.poll());
        }
        return res;
    }
```



##### 10.21 买卖股票的最好时机

https://www.nowcoder.com/practice/64b4262d4e6d4f6181cd45446a5821ec?tpId=190&&tqId=35181&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking

这是一个典型的动态规划问题。

- **最优子结构**

  在自下而上的递推过程中，我们求得的每个子问题一定是**全局最优解**，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。

- **重复子问题**

  递归地寻找子问题的最优解时，子问题会重叠地出现在子问题里，会有很多重复的计算，动态规划可以保证每个重叠的子问题只会被求解一次。

动态规划解题步骤：

1. 定义子问题
2. 写出子问题的递推关系
3. 确定DP数组的计算顺序

本题中的具体表现为：

```
dp[i]  i天卖出的最大收益``
buy 买进日期``
sell 卖出日期``
dp[i] = 今天卖出日期-最小买进日期;
dp[``0``] = ``0``;
```



```
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        // write code here
        int res = 0;
        int len = prices.length;
        int dp =  prices[0];
        int buy = prices[0];
        int sell = prices[0];
        for(int i = 1; i < len; i++){
            sell = prices[i];
            if(sell < buy) buy = sell;
            dp = sell - buy;
            res = Math.max(dp, res);
        }

        return res;
    }
}
```



##### 10.22 判断是否回文

https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2?tpId=190&&tqId=36606&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking

题中说了只有小写字母，最简单的就是使用双指针，一个指向前，一个指向后，两个指针同时往中间走，如果两个指针指向的字符不一样就返回false



```
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
       public boolean judge(String str) {
        if (str.length() == 0)
            return true;
        //两个指针，一个从左边开始，一个从右边开始，每次两个
        //指针都同时往中间挪，只要两个指针指向的字符不一样就返回false
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left++) != str.charAt(right--))
                return false;
        }
        return true;
    }
}
```



##### 10.23 二叉树的最大深度



```
   public class Solution{
   
         public int MaxDepth(TreeNode root){
         
         
                int leftDepth = MaxDepth(rooot.left);
                int rightDepth = MaxDepyyh(root.right);
                
                return Matn.max(leftDepth , rightDepth) +1;
         
         
         }
   
   }
```



##### 10.24  判断该二叉树是否是平衡二叉树



```
public class Solution {
    boolean flag = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root==null) return true;
        pre(root);
        return flag;
    }
    public int pre(TreeNode root){
        if(root==null) return 0;
        int left = pre(root.left);
        int right = pre(root.right);
        if(Math.abs(left-right)>1) flag = false;
        return Math.max(left,right)+1;
    }
}
```



##### 10.25 合并K个已排序的链表



```
public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        int size = lists.size();
        if(size == 0){
            return null;
        }
        if(size == 1){
            return lists.get(0);
        }
        ListNode node = lists.get(0);
        for(int i = 1; i < size; i++){
            //参数为 node ，list.size()>2,会多次合并，不可用lists.get(0)
             node = mergeLists(node,lists.get(i));
        }
        return node;
        
    }
    
    public ListNode mergeLists(ListNode node1,ListNode node2){
        ListNode node = new ListNode(-1);
        //操作temp 会有些数据丢失，关联node 同时用node 保存链表
        ListNode temp = node;
        while(node1 != null && node2 != null){
            if(node1.val < node2.val){
                temp.next = node1;
                node1 = node1.next;
            }else{
                temp.next = node2;
                node2 = node2.next;
            }
            //为了后面的连接temp.next = node1 != null ? node1 : node2;
            temp = temp.next;
        }
        //temp 连接多余的node
        temp.next = node1 != null ? node1 : node2;
        return node.next;
    }
}
```



##### 10.26 删除链表的重复元素



```
   public class Solution{
   
         public 
   
   }
```



##### 10.27 多线程打印ABC



###### 使用ReentrantLock

```
public class Solution{

         private static ReentrantLock lock = new Reentrantlock();
         private static int state = 0;
         
         static class ThreadA extends Thread{
         
                @Override
                public void run(){
                
                 for(int i =0 ;i< 10 ;i++){
                 
                   try{
                         lock.lock();
                        if(state % 3 = 0){
                           system.out.print("A");
                           state++;
                           i++;
                        }
                   
                   }catch{
                     e.printTrace();
                   }finally{
                      lock.unlock();
                   
                   }
                 
                 }
                
                
                }
                
         
         }
         
         static class ThreadB extends Thread{
         
               @Override
               public void run(){
               
                  for(int i=0;i<10;i++){
                  
                       try{
                           lock.lock();
                         if(state % 3 = 1){
                         
                      
                          System.out.print("C");
                          state++;
                          i++
                           
                         
                         }
                       
                       }finally{
                       
                         lock.unlock();
                       }
                  
                  }
               
               }
         
         }
         
         static class ThreadC extend Thread{
         
                 @Override
                 public void run(){
                 
                      for(int i = 0 ; i<10 ; i++){
                      
                           try{
                               lock.lock();
                               if( state % 3 == 3 ){
                               
                                 state++;
                                 i++;
                               }
                                 
                           
                           }finally{
                           
                             lock.unlock();
                           }
                      }
                 
                 }
                 
         
         }


}
```



##### 10.28 二叉搜索树的第k大节点

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/

```
public class Solution {

    private static List<Integer> arr=new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        //中序遍历,正序赋值数组
        inOrder(root);
        //寻找第k大的数，输出
        return arr.get(arr.size()-k);
    }
    //中序遍历
    private static void inOrder(TreeNode root){
        if(root==null)
            return;
        inOrder(root.left);
        arr.add(root.val);
        inOrder(root.right);

    }
}

```



##### 10.29 合并二叉树



```

```



##### 10.30  [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)



```

```



##### 10.31 [最小面积矩形](https://leetcode-cn.com/problems/minimum-area-rectangle/)

##### 10.32 顺时针打印矩阵

https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/jian-zhi-offer-29-shun-shi-zhen-da-yin-j-7049/

```
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix == null || matrix.length == 0) return new int[0];
        int n = matrix.length, m = matrix[0].length;
        int top = 0, bottom = n - 1;
        int left = 0, right = m - 1;
        int[] res = new int[n * m];
        int index = 0;
        while(true){
            // 左 -> 右
            for(int i = left; i <= right; i++){
                res[index++] = matrix[top][i];
            }
            top++;
            if(top > bottom) break;

            // 上 -> 下
            for(int i = top; i <= bottom; i++){
                res[index++] = matrix[i][right];
            }
            right--;
            if(left > right) break;

            // 右 -> 左
            for(int i = right; i >= left; i--){
                res[index++] = matrix[bottom][i];
            }
            bottom--;
            if(top > bottom) break;

            // 下 -> 上
            for(int i = bottom; i >= top; i--){
                res[index++] = matrix[i][left];
            }
            left++;
            if(left > right) break;
        }
        return res;
    }
}

作者：edelweisskoko
链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/jian-zhi-offer-29-shun-shi-zhen-da-yin-j-7049/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



##### 10.33 旋转矩阵

```
先上下交换，在对角线交换
```

![leet0048.png](https://pic.leetcode-cn.com/1615651665-WFwYuH-leet0048.png)

https://leetcode-cn.com/problems/rotate-matrix-lcci/solution/shu-ju-jie-gou-he-suan-fa-liang-chong-sh-vkrf/

```
    public void rotate(int[][] matrix) {
        int length = matrix.length;
        //先上下交换
        for (int i = 0; i < length / 2; i++) {
            int temp[] = matrix[i];
            matrix[i] = matrix[length - i - 1];
            matrix[length - i - 1] = temp;
        }
        //在按照对角线交换
        for (int i = 0; i < length; ++i) {
            for (int j = i + 1; j < length; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }

```

##### 10.34 [二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/

```
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int i = matrix.length - 1, j = 0;
        while(i >= 0 && j < matrix[0].length)
        {
            if(matrix[i][j] > target) i--;
            else if(matrix[i][j] < target) j++;
            else return true;
        }
        return false;
    }
}

```

##### 10.35 [ 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/

##### 10.36 链表指定区间反转

https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=188&&tqId=38555&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummy = new ListNode(-1);  // 哑巴节点，指向链表的头部
        dummy.next = head;
        ListNode pre = dummy;  // pre 指向要翻转子链表的前驱节点
        for (int i = 1; i < m; ++i) {
            pre = pre.next;
        }
        head = pre.next;  // head指向翻转子链表的首部
        ListNode next;
        for (int i = m; i < n; ++i) {
            next = head.next;
            // head节点连接next节点之后链表部分，也就是向后移动一位
            head.next = next.next;
            // next节点移动到需要反转链表部分的首部
            next.next = pre.next;
            // pre继续为需要反转头节点的前驱节点
            pre.next = next;
        }
        return dummy.next;
    }
}
```



##### 10.37 连续子数组的最大和

动态规划

https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=117&&tqId=37797&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking

```
典型的动态规划。dp[n]代表以当前元素为截止点的连续子序列的最大和，如果dp[n-1]>0，dp[n]=dp[n]+dp[n-1]，因为当前数字加上一个正数一定会变大；如果dp[n-1]<0，dp[n]不变，因为当前数字加上一个负数一定会变小。使用一个变量max记录最大的dp值返回即可。

public int FindGreatestSumOfSubArray(int[] array) {
    int max = array[0];
    for (int i = 1; i < array.length; i++) {
        array[i] += array[i - 1] > 0 ? array[i - 1] : 0;
        max = Math.max(max, array[i]);
    }
    return max;
}
```



##### 10.38 最长无重复子数组

https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=117&&tqId=37816&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking

```
我们还可以用一个队列，把元素不停的加入到队列中，如果有相同的元素，就把队首的元素移除，这样我们就可以保证队列中永远都没有重复的元素

    public int maxLength(int[] arr) {
        //用链表实现队列，队列是先进先出的
        Queue<Integer> queue = new LinkedList<>();
        int res = 0;
        for (int c : arr) {
            while (queue.contains(c)) {
                //如果有重复的，队头出队
                queue.poll();
            }
            //添加到队尾
            queue.add(c);
            res = Math.max(res, queue.size());
        }
        return res;
    }
```



##### 10.39

10.40

10.41

10.42

10.43

10.44

10.45

10.46

10.47

##### 10.48  手撕阻塞队列

```

```



##### 10.49 手撕线程死锁



https://blog.csdn.net/qq_38215042/article/details/87859890

```
public class Solution{

   Object t1 = new Object();
   Object t2 = new Object();
   
   new Thread (new Runnable(){
       
       @Override
       public void run(){
       
         String name = Thread,currentThread().getName();
         synchronized(t1){
          System.out.print("当前线程" + name);
          try{
          
             Thread.sleep(100);
          }catch( InterruptedException e)
           
           e.printStackTrace();
         }
         
         synchronized(t2){
         
            System.out.print("ddddd");
         }
         
       
       }
   
   },"线程A").start();
   
   
   new Thread(new Runnable(){
       @Override
       public void run(){
       
          String name = Thread.currentThread().getName();
          synchronized(t2){
          
            System,out.print("当前线程" + name);
            
            try{
            
              Thread.sleep(100);
            
            }catch( InterruptedException e){
            
              e.printStackTrace();
            }
            
            synchronized(t1){
            
               System.out.print("dddddd");
            }
            
          }
       
       }
   
   
   },"线程B").start();
   
}
```



##### 10.50 ThreadLocal

```
public class LoginInfoThreadLocal{

   private static final ThreadLocal<LoginInfo> local = new ThreadLocal<LoginInfo>();
   
   
   public static void set(LoginInfo bean){
   
      local.set(bean);
   }
   
   public static LoginInfo get(){
   
      local.get();
   }

}
```



#### 11. JVM

##### 11.1  JVM内存模型



```
程序计数器  ， 记录CPU指令，私有
java虚拟机栈，私有
本地虚拟机栈，私有
堆内存
方法区

```

##### 11.2 编译原理



```
1. 词法分析 ，token流

2. 语法分析，

3. 语义分析；

4. 字节码生成，
```

**java 如何从源代码转换成机器码执行的**



##### 11.3 类加载过程



```
1. 加载

2. 链接：
   
   验证，语法是否符合JVM规范
   准备，给静态变量赋值，int = 0
   解释, 间接引用转为直接引用
   
3. 初始化

4. 卸载
```



##### 11.4 类加载的顺序



```
1. 父类静态方法
2. 子类静态方法
3. 父类普通方法
4. 父类构造函数
5. 子类普通方法
6. 子类构造函数
```

##### 11.5 双亲委派机制

https://www.jianshu.com/p/9b2d43c9a09a

https://www.cnblogs.com/aspirant/p/8991830.html

```
1. 启动类加载器  Bootstrap ClassLoader ：

启动类加载器,负责加载java基础类，对应的文件是%JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等

2. 拓展类加载器  Extension ClassLoader：

对应的文件是 %JRE_HOME/lib/ext 目录下的jar和class等

3. 应用类加载器  App ClassLoader：

对应的文件是应用程序classpath目录下的所有jar和class等


4. 自定义加载类

加载一个类的时候，先用父类去加载，如果父类加载没有，再给子类加载
```



**自定义一个类加载器**

https://blog.csdn.net/huazai30000/article/details/85296671

```
public class MyClassLoader extends ClassLoader {
    //指定路径
    private String path ;
 
 
    public MyClassLoader(String classPath){
        path=classPath;
    }
 
    /**
     * 重写findClass方法
     * @param name 是我们这个类的全路径
     * @return
     * @throws ClassNotFoundException
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        Class log = null;
        // 获取该class文件字节码数组
        byte[] classData = getData();
 
        if (classData != null) {
            // 将class的字节码数组转换成Class类的实例
            log = defineClass(name, classData, 0, classData.length);
        }
        return log;
    }
 
    /**
     * 将class文件转化为字节码数组
     * @return
     */
    private byte[] getData() {
 
        File file = new File(path);
        if (file.exists()){
            FileInputStream in = null;
            ByteArrayOutputStream out = null;
            try {
                in = new FileInputStream(file);
                out = new ByteArrayOutputStream();
 
                byte[] buffer = new byte[1024];
                int size = 0;
                while ((size = in.read(buffer)) != -1) {
                    out.write(buffer, 0, size);
                }
 
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    in.close();
                } catch (IOException e) {
 
                    e.printStackTrace();
                }
            }
            return out.toByteArray();
        }else{
            return null;
        }
 
 
    }
}
```



**打破双亲委派机制**

https://www.jianshu.com/p/9b2d43c9a09a

https://cloud.tencent.com/developer/article/1706851

https://www.cnblogs.com/cl-rr/p/9081817.html

```
1. JDBC，通过使用线程上下午类加载器打破

2. Tomacat , 每一个应用都会生成 webAppClassLoader
```



##### 11.6  垃圾回收算法

https://blog.csdn.net/weixin_43213517/article/details/89853530



| 算法     | 优点         | 缺点     |
| :------- | ------------ | -------- |
| 标记清除 |              | 产生碎片 |
| 标记整理 | 不会产生碎片 |          |
| 复制算法 |              |          |
| 分代回收 |              |          |



##### 11.7 垃圾回收器



```
串行
series
seriesOld

并行
parNew
pallre

cms

G1
```



##### 11.8  JVM调优

```

```





##### 11.9  老年代担保机制

https://blog.csdn.net/weixin_38106322/article/details/108893760

```
当新生代被分配了大对象(该对象大小可以通过参数设置)，或者经过Minor GC后，存活下来的对象，Survivor区放不下，那么这些对象都会被分配到老年代。

老年代想担保就能担保？
老年代空间也是有限的，既然不是无限大，那么老年代在担保前也得自己掂量下，自己是不是吃的下那些要分配给自己的对象。

老年代想要担保需要遵守什么规则？
在执行任何一次Minor GC前，JVM都会检查一下老年代的的可用内存空间，然后和新生代中的所有对象的大小总和做个比较，如果大于新生代中的所有对象的大小总和，那么就可以保证Minor GC后，即使新生代中所有的对象都存活下来，Survivor区放不下，老年代也是能够完全分配下这些对象的。如果老年代的的可用内存空间是小于新生代中的所有对象的大小总和的，那么就要继续走第二步的判断。
第二步判断，要看看是否设置了“-XX:-HandlePromotionFailure”参数，该参数的作用在于会多加一步判断规则：判断老年代的的可用内存空间是否大于之前每一次Minor GC后进入老年代的对象的平均大小。如果不加这个参数或者这个参数判断失败，同时老年代的的可用内存空间小于新生代中的所有对象的大小总和，就会直接进行Full GC，尽量先腾出一些老年代空间来，然后再触发Minor GC，尽最大努力防止出现OOM。如果“-XX:-HandlePromotionFailure”参数判断是成功的，那么就走第三步。
第三步就可以试着进行Minor GC了，毕竟该做的判断做了和该满足的条件都有了，此时Minor GC后，如果存活的对象大小小于Survivor区的大小，那么存活的对象直接进入Survivor区。如果存活的对象大小大于Survivor区的大小，却小于老年代大小，那么存活的对象直接进入老年代。最极端的情况就是存活的对象大小大于Survivor区的大小，同时也大于老年代大小，那么此时机会触发一次Full GC，对老年代和新生代统一做一次垃圾回收，腾出空间，方便让Minor GC后存活的对象可以进入老年代。最差的情况就是即使经过了Full GC，老年代空间也还是不够，那么就会爆出OOM了。
————————————————

```



```
在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlerPromotionFailure设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。如果大于，将尝试着进行一次Monitor GC，尽管这次GC是有风险的。如果小于，或者HandlerPromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC了。

上述所说的冒险到底是冒的什么险呢？

前面提到过，新生代使用复制收集算法，但是为了内存利用率。只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况是内存回收之后，新生代中所有的对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象存活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败。如果出现HandlerPromotionFailure失败，那就只好在失败后重新发起一次FULL GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是将HandlerPromotionFailure开关打开，避免Full GC过于频繁。
```



##### 11.10

##### 11.11

##### 11.12

##### 11.13

##### 11.14

##### 11.15  算法稳定性

https://www.cnblogs.com/lqminn/p/3642027.html

https://www.cnblogs.com/Leophen/p/11397731.html

http://www.javashuo.com/article/p-cqlytcrs-go.html

https://www.jianshu.com/p/a5b5b5c4ee0f



#### 12 Redis

##### 12.1 常见的数据结构

###### String 

```
底层结构，SDS ，动态字符串

1. 安全性高，二进制
2. 
```

Hash

```
渐进式哈希
```



###### set

```

```



###### sortedSet

```

```



###### List

```

```



###### 跳跃表



###### 布隆过滤





##### 12.2  常用命令



```

```

##### 12.3 RDB和AOF

```
重写的过程
```



##### 12.4 redis缓存和mysql数据库数据一致性如何保证



```
1. 只删除缓存不更新缓存

2. 
```

##### 12.5  集群模式



```
1. 主从模式
2. 哨兵模式
3. 集群模式
```

##### 12.6  redis 3 种集群方案

https://blog.csdn.net/QQ1006207580/article/details/103243281

https://www.cnblogs.com/pingyeaa/p/11294773.html

https://www.cnblogs.com/kaleidoscope/p/9630316.html

https://www.cnblogs.com/phyger/p/14277330.html

**cluster**

```

```

**codis**

```

```



##### 12.7 pipline是全双工还是半双工



12.8

12.9

12.10

12.11

#### 13. Es

##### 13.1  为什么那么快

##### 13.2  节点类型

##### 13.3   写的过程

##### 13.4  读的过程

##### 13.5

13.6

13.7

13.8

13.9



#### 14 kafka

##### 14.1 基本概念

```
1. broker

2. Topic

3. product

4. consume

5. consume group

6. p

7. ISR

8. OSR


```

##### 14.2  为啥那么快

```
1. 纯内存操作
2. 顺序寻址
3. 批量处理
4. 
```





##### 14.3 如何保证消息不丢失

##### 14.4 如何保证消息的顺序性

##### 14.5 如何

14.6

14.7

14.8

14.9

#### 15. 设计

https://www.cnblogs.com/xiaonian8/p/14111463.html

https://blog.csdn.net/linuxguitu/article/details/111676210

#### 16. linux

##### 16.1

16.2

16.3

16.4

16.5

16.6

16.7

16.8

16.9

